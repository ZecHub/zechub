// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod fb {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    pub enum IdListOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct IdList<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for IdList<'a> {
        type Inner = IdList<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> IdList<'a> {
        pub const VT_IDS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            IdList { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args IdListArgs<'args>,
        ) -> flatbuffers::WIPOffset<IdList<'bldr>> {
            let mut builder = IdListBuilder::new(_fbb);
            if let Some(x) = args.ids {
                builder.add_ids(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> IdListT {
            let ids = self.ids().map(|x| x.into_iter().collect());
            IdListT { ids }
        }

        #[inline]
        pub fn ids(&self) -> Option<flatbuffers::Vector<'a, u32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                        IdList::VT_IDS,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for IdList<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                    "ids",
                    Self::VT_IDS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct IdListArgs<'a> {
        pub ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    }
    impl<'a> Default for IdListArgs<'a> {
        #[inline]
        fn default() -> Self {
            IdListArgs { ids: None }
        }
    }

    pub struct IdListBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdListBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_ids(&mut self, ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(IdList::VT_IDS, ids);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> IdListBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            IdListBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<IdList<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for IdList<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("IdList");
            ds.field("ids", &self.ids());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct IdListT {
        pub ids: Option<Vec<u32>>,
    }
    impl Default for IdListT {
        fn default() -> Self {
            Self { ids: None }
        }
    }
    impl IdListT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<IdList<'b>> {
            let ids = self.ids.as_ref().map(|x| _fbb.create_vector(x));
            IdList::create(_fbb, &IdListArgs { ids })
        }
    }
    pub enum AccountOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Account<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Account<'a> {
        type Inner = Account<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Account<'a> {
        pub const VT_COIN: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;
        pub const VT_NAME: flatbuffers::VOffsetT = 8;
        pub const VT_KEY_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_BALANCE: flatbuffers::VOffsetT = 12;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 14;
        pub const VT_SAVED: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Account { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AccountArgs<'args>,
        ) -> flatbuffers::WIPOffset<Account<'bldr>> {
            let mut builder = AccountBuilder::new(_fbb);
            builder.add_balance(args.balance);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_id(args.id);
            builder.add_saved(args.saved);
            builder.add_key_type(args.key_type);
            builder.add_coin(args.coin);
            builder.finish()
        }

        pub fn unpack(&self) -> AccountT {
            let coin = self.coin();
            let id = self.id();
            let name = self.name().map(|x| x.to_string());
            let key_type = self.key_type();
            let balance = self.balance();
            let address = self.address().map(|x| x.to_string());
            let saved = self.saved();
            AccountT {
                coin,
                id,
                name,
                key_type,
                balance,
                address,
                saved,
            }
        }

        #[inline]
        pub fn coin(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u8>(Account::VT_COIN, Some(0)).unwrap() }
        }
        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Account::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Account::VT_NAME, None)
            }
        }
        #[inline]
        pub fn key_type(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u8>(Account::VT_KEY_TYPE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn balance(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Account::VT_BALANCE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Account::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn saved(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Account::VT_SAVED, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Account<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u8>("coin", Self::VT_COIN, false)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<u8>("key_type", Self::VT_KEY_TYPE, false)?
                .visit_field::<u64>("balance", Self::VT_BALANCE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<bool>("saved", Self::VT_SAVED, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AccountArgs<'a> {
        pub coin: u8,
        pub id: u32,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub key_type: u8,
        pub balance: u64,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub saved: bool,
    }
    impl<'a> Default for AccountArgs<'a> {
        #[inline]
        fn default() -> Self {
            AccountArgs {
                coin: 0,
                id: 0,
                name: None,
                key_type: 0,
                balance: 0,
                address: None,
                saved: false,
            }
        }
    }

    pub struct AccountBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AccountBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_coin(&mut self, coin: u8) {
            self.fbb_.push_slot::<u8>(Account::VT_COIN, coin, 0);
        }
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(Account::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Account::VT_NAME, name);
        }
        #[inline]
        pub fn add_key_type(&mut self, key_type: u8) {
            self.fbb_.push_slot::<u8>(Account::VT_KEY_TYPE, key_type, 0);
        }
        #[inline]
        pub fn add_balance(&mut self, balance: u64) {
            self.fbb_.push_slot::<u64>(Account::VT_BALANCE, balance, 0);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Account::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_saved(&mut self, saved: bool) {
            self.fbb_.push_slot::<bool>(Account::VT_SAVED, saved, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AccountBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AccountBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Account<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Account<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Account");
            ds.field("coin", &self.coin());
            ds.field("id", &self.id());
            ds.field("name", &self.name());
            ds.field("key_type", &self.key_type());
            ds.field("balance", &self.balance());
            ds.field("address", &self.address());
            ds.field("saved", &self.saved());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct AccountT {
        pub coin: u8,
        pub id: u32,
        pub name: Option<String>,
        pub key_type: u8,
        pub balance: u64,
        pub address: Option<String>,
        pub saved: bool,
    }
    impl Default for AccountT {
        fn default() -> Self {
            Self {
                coin: 0,
                id: 0,
                name: None,
                key_type: 0,
                balance: 0,
                address: None,
                saved: false,
            }
        }
    }
    impl AccountT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Account<'b>> {
            let coin = self.coin;
            let id = self.id;
            let name = self.name.as_ref().map(|x| _fbb.create_string(x));
            let key_type = self.key_type;
            let balance = self.balance;
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let saved = self.saved;
            Account::create(
                _fbb,
                &AccountArgs {
                    coin,
                    id,
                    name,
                    key_type,
                    balance,
                    address,
                    saved,
                },
            )
        }
    }
    pub enum AccountVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AccountVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AccountVec<'a> {
        type Inner = AccountVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AccountVec<'a> {
        pub const VT_ACCOUNTS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AccountVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AccountVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<AccountVec<'bldr>> {
            let mut builder = AccountVecBuilder::new(_fbb);
            if let Some(x) = args.accounts {
                builder.add_accounts(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> AccountVecT {
            let accounts = self
                .accounts()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            AccountVecT { accounts }
        }

        #[inline]
        pub fn accounts(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Account<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Account>>,
                >>(AccountVec::VT_ACCOUNTS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for AccountVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Account>>,
                >>("accounts", Self::VT_ACCOUNTS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AccountVecArgs<'a> {
        pub accounts: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Account<'a>>>,
            >,
        >,
    }
    impl<'a> Default for AccountVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            AccountVecArgs { accounts: None }
        }
    }

    pub struct AccountVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AccountVecBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_accounts(
            &mut self,
            accounts: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Account<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AccountVec::VT_ACCOUNTS, accounts);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AccountVecBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AccountVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AccountVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AccountVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AccountVec");
            ds.field("accounts", &self.accounts());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct AccountVecT {
        pub accounts: Option<Vec<AccountT>>,
    }
    impl Default for AccountVecT {
        fn default() -> Self {
            Self { accounts: None }
        }
    }
    impl AccountVecT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<AccountVec<'b>> {
            let accounts = self.accounts.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            AccountVec::create(_fbb, &AccountVecArgs { accounts })
        }
    }
    pub enum BalanceOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Balance<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Balance<'a> {
        type Inner = Balance<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Balance<'a> {
        pub const VT_SHIELDED: flatbuffers::VOffsetT = 4;
        pub const VT_UNCONFIRMED_SPENT: flatbuffers::VOffsetT = 6;
        pub const VT_BALANCE: flatbuffers::VOffsetT = 8;
        pub const VT_UNDER_CONFIRMED: flatbuffers::VOffsetT = 10;
        pub const VT_EXCLUDED: flatbuffers::VOffsetT = 12;
        pub const VT_SAPLING: flatbuffers::VOffsetT = 14;
        pub const VT_ORCHARD: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Balance { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BalanceArgs,
        ) -> flatbuffers::WIPOffset<Balance<'bldr>> {
            let mut builder = BalanceBuilder::new(_fbb);
            builder.add_orchard(args.orchard);
            builder.add_sapling(args.sapling);
            builder.add_excluded(args.excluded);
            builder.add_under_confirmed(args.under_confirmed);
            builder.add_balance(args.balance);
            builder.add_unconfirmed_spent(args.unconfirmed_spent);
            builder.add_shielded(args.shielded);
            builder.finish()
        }

        pub fn unpack(&self) -> BalanceT {
            let shielded = self.shielded();
            let unconfirmed_spent = self.unconfirmed_spent();
            let balance = self.balance();
            let under_confirmed = self.under_confirmed();
            let excluded = self.excluded();
            let sapling = self.sapling();
            let orchard = self.orchard();
            BalanceT {
                shielded,
                unconfirmed_spent,
                balance,
                under_confirmed,
                excluded,
                sapling,
                orchard,
            }
        }

        #[inline]
        pub fn shielded(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Balance::VT_SHIELDED, Some(0)).unwrap() }
        }
        #[inline]
        pub fn unconfirmed_spent(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(Balance::VT_UNCONFIRMED_SPENT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn balance(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Balance::VT_BALANCE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn under_confirmed(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(Balance::VT_UNDER_CONFIRMED, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn excluded(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Balance::VT_EXCLUDED, Some(0)).unwrap() }
        }
        #[inline]
        pub fn sapling(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Balance::VT_SAPLING, Some(0)).unwrap() }
        }
        #[inline]
        pub fn orchard(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Balance::VT_ORCHARD, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Balance<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("shielded", Self::VT_SHIELDED, false)?
                .visit_field::<u64>("unconfirmed_spent", Self::VT_UNCONFIRMED_SPENT, false)?
                .visit_field::<u64>("balance", Self::VT_BALANCE, false)?
                .visit_field::<u64>("under_confirmed", Self::VT_UNDER_CONFIRMED, false)?
                .visit_field::<u64>("excluded", Self::VT_EXCLUDED, false)?
                .visit_field::<u64>("sapling", Self::VT_SAPLING, false)?
                .visit_field::<u64>("orchard", Self::VT_ORCHARD, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BalanceArgs {
        pub shielded: u64,
        pub unconfirmed_spent: u64,
        pub balance: u64,
        pub under_confirmed: u64,
        pub excluded: u64,
        pub sapling: u64,
        pub orchard: u64,
    }
    impl<'a> Default for BalanceArgs {
        #[inline]
        fn default() -> Self {
            BalanceArgs {
                shielded: 0,
                unconfirmed_spent: 0,
                balance: 0,
                under_confirmed: 0,
                excluded: 0,
                sapling: 0,
                orchard: 0,
            }
        }
    }

    pub struct BalanceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BalanceBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_shielded(&mut self, shielded: u64) {
            self.fbb_
                .push_slot::<u64>(Balance::VT_SHIELDED, shielded, 0);
        }
        #[inline]
        pub fn add_unconfirmed_spent(&mut self, unconfirmed_spent: u64) {
            self.fbb_
                .push_slot::<u64>(Balance::VT_UNCONFIRMED_SPENT, unconfirmed_spent, 0);
        }
        #[inline]
        pub fn add_balance(&mut self, balance: u64) {
            self.fbb_.push_slot::<u64>(Balance::VT_BALANCE, balance, 0);
        }
        #[inline]
        pub fn add_under_confirmed(&mut self, under_confirmed: u64) {
            self.fbb_
                .push_slot::<u64>(Balance::VT_UNDER_CONFIRMED, under_confirmed, 0);
        }
        #[inline]
        pub fn add_excluded(&mut self, excluded: u64) {
            self.fbb_
                .push_slot::<u64>(Balance::VT_EXCLUDED, excluded, 0);
        }
        #[inline]
        pub fn add_sapling(&mut self, sapling: u64) {
            self.fbb_.push_slot::<u64>(Balance::VT_SAPLING, sapling, 0);
        }
        #[inline]
        pub fn add_orchard(&mut self, orchard: u64) {
            self.fbb_.push_slot::<u64>(Balance::VT_ORCHARD, orchard, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> BalanceBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BalanceBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Balance<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Balance<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Balance");
            ds.field("shielded", &self.shielded());
            ds.field("unconfirmed_spent", &self.unconfirmed_spent());
            ds.field("balance", &self.balance());
            ds.field("under_confirmed", &self.under_confirmed());
            ds.field("excluded", &self.excluded());
            ds.field("sapling", &self.sapling());
            ds.field("orchard", &self.orchard());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct BalanceT {
        pub shielded: u64,
        pub unconfirmed_spent: u64,
        pub balance: u64,
        pub under_confirmed: u64,
        pub excluded: u64,
        pub sapling: u64,
        pub orchard: u64,
    }
    impl Default for BalanceT {
        fn default() -> Self {
            Self {
                shielded: 0,
                unconfirmed_spent: 0,
                balance: 0,
                under_confirmed: 0,
                excluded: 0,
                sapling: 0,
                orchard: 0,
            }
        }
    }
    impl BalanceT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Balance<'b>> {
            let shielded = self.shielded;
            let unconfirmed_spent = self.unconfirmed_spent;
            let balance = self.balance;
            let under_confirmed = self.under_confirmed;
            let excluded = self.excluded;
            let sapling = self.sapling;
            let orchard = self.orchard;
            Balance::create(
                _fbb,
                &BalanceArgs {
                    shielded,
                    unconfirmed_spent,
                    balance,
                    under_confirmed,
                    excluded,
                    sapling,
                    orchard,
                },
            )
        }
    }
    pub enum PoolBalanceOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PoolBalance<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PoolBalance<'a> {
        type Inner = PoolBalance<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PoolBalance<'a> {
        pub const VT_TRANSPARENT: flatbuffers::VOffsetT = 4;
        pub const VT_SAPLING: flatbuffers::VOffsetT = 6;
        pub const VT_ORCHARD: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PoolBalance { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args PoolBalanceArgs,
        ) -> flatbuffers::WIPOffset<PoolBalance<'bldr>> {
            let mut builder = PoolBalanceBuilder::new(_fbb);
            builder.add_orchard(args.orchard);
            builder.add_sapling(args.sapling);
            builder.add_transparent(args.transparent);
            builder.finish()
        }

        pub fn unpack(&self) -> PoolBalanceT {
            let transparent = self.transparent();
            let sapling = self.sapling();
            let orchard = self.orchard();
            PoolBalanceT {
                transparent,
                sapling,
                orchard,
            }
        }

        #[inline]
        pub fn transparent(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(PoolBalance::VT_TRANSPARENT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn sapling(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(PoolBalance::VT_SAPLING, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn orchard(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(PoolBalance::VT_ORCHARD, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for PoolBalance<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("transparent", Self::VT_TRANSPARENT, false)?
                .visit_field::<u64>("sapling", Self::VT_SAPLING, false)?
                .visit_field::<u64>("orchard", Self::VT_ORCHARD, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PoolBalanceArgs {
        pub transparent: u64,
        pub sapling: u64,
        pub orchard: u64,
    }
    impl<'a> Default for PoolBalanceArgs {
        #[inline]
        fn default() -> Self {
            PoolBalanceArgs {
                transparent: 0,
                sapling: 0,
                orchard: 0,
            }
        }
    }

    pub struct PoolBalanceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PoolBalanceBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_transparent(&mut self, transparent: u64) {
            self.fbb_
                .push_slot::<u64>(PoolBalance::VT_TRANSPARENT, transparent, 0);
        }
        #[inline]
        pub fn add_sapling(&mut self, sapling: u64) {
            self.fbb_
                .push_slot::<u64>(PoolBalance::VT_SAPLING, sapling, 0);
        }
        #[inline]
        pub fn add_orchard(&mut self, orchard: u64) {
            self.fbb_
                .push_slot::<u64>(PoolBalance::VT_ORCHARD, orchard, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> PoolBalanceBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            PoolBalanceBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PoolBalance<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PoolBalance<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PoolBalance");
            ds.field("transparent", &self.transparent());
            ds.field("sapling", &self.sapling());
            ds.field("orchard", &self.orchard());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct PoolBalanceT {
        pub transparent: u64,
        pub sapling: u64,
        pub orchard: u64,
    }
    impl Default for PoolBalanceT {
        fn default() -> Self {
            Self {
                transparent: 0,
                sapling: 0,
                orchard: 0,
            }
        }
    }
    impl PoolBalanceT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<PoolBalance<'b>> {
            let transparent = self.transparent;
            let sapling = self.sapling;
            let orchard = self.orchard;
            PoolBalance::create(
                _fbb,
                &PoolBalanceArgs {
                    transparent,
                    sapling,
                    orchard,
                },
            )
        }
    }
    pub enum HeightOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Height<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Height<'a> {
        type Inner = Height<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Height<'a> {
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Height { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args HeightArgs,
        ) -> flatbuffers::WIPOffset<Height<'bldr>> {
            let mut builder = HeightBuilder::new(_fbb);
            builder.add_timestamp(args.timestamp);
            builder.add_height(args.height);
            builder.finish()
        }

        pub fn unpack(&self) -> HeightT {
            let height = self.height();
            let timestamp = self.timestamp();
            HeightT { height, timestamp }
        }

        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Height::VT_HEIGHT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Height::VT_TIMESTAMP, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Height<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .finish();
            Ok(())
        }
    }
    pub struct HeightArgs {
        pub height: u32,
        pub timestamp: u32,
    }
    impl<'a> Default for HeightArgs {
        #[inline]
        fn default() -> Self {
            HeightArgs {
                height: 0,
                timestamp: 0,
            }
        }
    }

    pub struct HeightBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HeightBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(Height::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(Height::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> HeightBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            HeightBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Height<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Height<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Height");
            ds.field("height", &self.height());
            ds.field("timestamp", &self.timestamp());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct HeightT {
        pub height: u32,
        pub timestamp: u32,
    }
    impl Default for HeightT {
        fn default() -> Self {
            Self {
                height: 0,
                timestamp: 0,
            }
        }
    }
    impl HeightT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Height<'b>> {
            let height = self.height;
            let timestamp = self.timestamp;
            Height::create(_fbb, &HeightArgs { height, timestamp })
        }
    }
    pub enum ShieldedNoteOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ShieldedNote<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ShieldedNote<'a> {
        type Inner = ShieldedNote<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ShieldedNote<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 10;
        pub const VT_ORCHARD: flatbuffers::VOffsetT = 12;
        pub const VT_EXCLUDED: flatbuffers::VOffsetT = 14;
        pub const VT_SPENT: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ShieldedNote { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ShieldedNoteArgs,
        ) -> flatbuffers::WIPOffset<ShieldedNote<'bldr>> {
            let mut builder = ShieldedNoteBuilder::new(_fbb);
            builder.add_value(args.value);
            builder.add_timestamp(args.timestamp);
            builder.add_height(args.height);
            builder.add_id(args.id);
            builder.add_spent(args.spent);
            builder.add_excluded(args.excluded);
            builder.add_orchard(args.orchard);
            builder.finish()
        }

        pub fn unpack(&self) -> ShieldedNoteT {
            let id = self.id();
            let height = self.height();
            let value = self.value();
            let timestamp = self.timestamp();
            let orchard = self.orchard();
            let excluded = self.excluded();
            let spent = self.spent();
            ShieldedNoteT {
                id,
                height,
                value,
                timestamp,
                orchard,
                excluded,
                spent,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(ShieldedNote::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedNote::VT_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(ShieldedNote::VT_VALUE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedNote::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn orchard(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(ShieldedNote::VT_ORCHARD, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn excluded(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(ShieldedNote::VT_EXCLUDED, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn spent(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(ShieldedNote::VT_SPENT, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ShieldedNote<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u64>("value", Self::VT_VALUE, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<bool>("orchard", Self::VT_ORCHARD, false)?
                .visit_field::<bool>("excluded", Self::VT_EXCLUDED, false)?
                .visit_field::<bool>("spent", Self::VT_SPENT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ShieldedNoteArgs {
        pub id: u32,
        pub height: u32,
        pub value: u64,
        pub timestamp: u32,
        pub orchard: bool,
        pub excluded: bool,
        pub spent: bool,
    }
    impl<'a> Default for ShieldedNoteArgs {
        #[inline]
        fn default() -> Self {
            ShieldedNoteArgs {
                id: 0,
                height: 0,
                value: 0,
                timestamp: 0,
                orchard: false,
                excluded: false,
                spent: false,
            }
        }
    }

    pub struct ShieldedNoteBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ShieldedNoteBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(ShieldedNote::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedNote::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_.push_slot::<u64>(ShieldedNote::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedNote::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_orchard(&mut self, orchard: bool) {
            self.fbb_
                .push_slot::<bool>(ShieldedNote::VT_ORCHARD, orchard, false);
        }
        #[inline]
        pub fn add_excluded(&mut self, excluded: bool) {
            self.fbb_
                .push_slot::<bool>(ShieldedNote::VT_EXCLUDED, excluded, false);
        }
        #[inline]
        pub fn add_spent(&mut self, spent: bool) {
            self.fbb_
                .push_slot::<bool>(ShieldedNote::VT_SPENT, spent, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ShieldedNoteBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ShieldedNoteBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ShieldedNote<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ShieldedNote<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ShieldedNote");
            ds.field("id", &self.id());
            ds.field("height", &self.height());
            ds.field("value", &self.value());
            ds.field("timestamp", &self.timestamp());
            ds.field("orchard", &self.orchard());
            ds.field("excluded", &self.excluded());
            ds.field("spent", &self.spent());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ShieldedNoteT {
        pub id: u32,
        pub height: u32,
        pub value: u64,
        pub timestamp: u32,
        pub orchard: bool,
        pub excluded: bool,
        pub spent: bool,
    }
    impl Default for ShieldedNoteT {
        fn default() -> Self {
            Self {
                id: 0,
                height: 0,
                value: 0,
                timestamp: 0,
                orchard: false,
                excluded: false,
                spent: false,
            }
        }
    }
    impl ShieldedNoteT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<ShieldedNote<'b>> {
            let id = self.id;
            let height = self.height;
            let value = self.value;
            let timestamp = self.timestamp;
            let orchard = self.orchard;
            let excluded = self.excluded;
            let spent = self.spent;
            ShieldedNote::create(
                _fbb,
                &ShieldedNoteArgs {
                    id,
                    height,
                    value,
                    timestamp,
                    orchard,
                    excluded,
                    spent,
                },
            )
        }
    }
    pub enum ShieldedNoteVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ShieldedNoteVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ShieldedNoteVec<'a> {
        type Inner = ShieldedNoteVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ShieldedNoteVec<'a> {
        pub const VT_NOTES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ShieldedNoteVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ShieldedNoteVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<ShieldedNoteVec<'bldr>> {
            let mut builder = ShieldedNoteVecBuilder::new(_fbb);
            if let Some(x) = args.notes {
                builder.add_notes(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> ShieldedNoteVecT {
            let notes = self.notes().map(|x| x.iter().map(|t| t.unpack()).collect());
            ShieldedNoteVecT { notes }
        }

        #[inline]
        pub fn notes(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShieldedNote<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShieldedNote>>,
                >>(ShieldedNoteVec::VT_NOTES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for ShieldedNoteVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ShieldedNote>>,
                >>("notes", Self::VT_NOTES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ShieldedNoteVecArgs<'a> {
        pub notes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShieldedNote<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ShieldedNoteVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            ShieldedNoteVecArgs { notes: None }
        }
    }

    pub struct ShieldedNoteVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ShieldedNoteVecBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_notes(
            &mut self,
            notes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ShieldedNote<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedNoteVec::VT_NOTES, notes);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ShieldedNoteVecBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ShieldedNoteVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ShieldedNoteVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ShieldedNoteVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ShieldedNoteVec");
            ds.field("notes", &self.notes());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ShieldedNoteVecT {
        pub notes: Option<Vec<ShieldedNoteT>>,
    }
    impl Default for ShieldedNoteVecT {
        fn default() -> Self {
            Self { notes: None }
        }
    }
    impl ShieldedNoteVecT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<ShieldedNoteVec<'b>> {
            let notes = self.notes.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            ShieldedNoteVec::create(_fbb, &ShieldedNoteVecArgs { notes })
        }
    }
    pub enum ShieldedTxOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ShieldedTx<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ShieldedTx<'a> {
        type Inner = ShieldedTx<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ShieldedTx<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_TX_ID: flatbuffers::VOffsetT = 6;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 8;
        pub const VT_SHORT_TX_ID: flatbuffers::VOffsetT = 10;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
        pub const VT_NAME: flatbuffers::VOffsetT = 14;
        pub const VT_VALUE: flatbuffers::VOffsetT = 16;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 18;
        pub const VT_MEMO: flatbuffers::VOffsetT = 20;
        pub const VT_MESSAGES: flatbuffers::VOffsetT = 22;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ShieldedTx { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ShieldedTxArgs<'args>,
        ) -> flatbuffers::WIPOffset<ShieldedTx<'bldr>> {
            let mut builder = ShieldedTxBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.messages {
                builder.add_messages(x);
            }
            if let Some(x) = args.memo {
                builder.add_memo(x);
            }
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.short_tx_id {
                builder.add_short_tx_id(x);
            }
            builder.add_height(args.height);
            if let Some(x) = args.tx_id {
                builder.add_tx_id(x);
            }
            builder.add_id(args.id);
            builder.finish()
        }

        pub fn unpack(&self) -> ShieldedTxT {
            let id = self.id();
            let tx_id = self.tx_id().map(|x| x.to_string());
            let height = self.height();
            let short_tx_id = self.short_tx_id().map(|x| x.to_string());
            let timestamp = self.timestamp();
            let name = self.name().map(|x| x.to_string());
            let value = self.value();
            let address = self.address().map(|x| x.to_string());
            let memo = self.memo().map(|x| x.to_string());
            let messages = self.messages().map(|x| Box::new(x.unpack()));
            ShieldedTxT {
                id,
                tx_id,
                height,
                short_tx_id,
                timestamp,
                name,
                value,
                address,
                memo,
                messages,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(ShieldedTx::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn tx_id(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ShieldedTx::VT_TX_ID, None)
            }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedTx::VT_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn short_tx_id(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ShieldedTx::VT_SHORT_TX_ID, None)
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedTx::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ShieldedTx::VT_NAME, None)
            }
        }
        #[inline]
        pub fn value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(ShieldedTx::VT_VALUE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ShieldedTx::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn memo(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ShieldedTx::VT_MEMO, None)
            }
        }
        #[inline]
        pub fn messages(&self) -> Option<MemoVec<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<MemoVec>>(ShieldedTx::VT_MESSAGES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for ShieldedTx<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tx_id", Self::VT_TX_ID, false)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "short_tx_id",
                    Self::VT_SHORT_TX_ID,
                    false,
                )?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<u64>("value", Self::VT_VALUE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memo", Self::VT_MEMO, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<MemoVec>>(
                    "messages",
                    Self::VT_MESSAGES,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ShieldedTxArgs<'a> {
        pub id: u32,
        pub tx_id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub height: u32,
        pub short_tx_id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub timestamp: u32,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: u64,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub memo: Option<flatbuffers::WIPOffset<&'a str>>,
        pub messages: Option<flatbuffers::WIPOffset<MemoVec<'a>>>,
    }
    impl<'a> Default for ShieldedTxArgs<'a> {
        #[inline]
        fn default() -> Self {
            ShieldedTxArgs {
                id: 0,
                tx_id: None,
                height: 0,
                short_tx_id: None,
                timestamp: 0,
                name: None,
                value: 0,
                address: None,
                memo: None,
                messages: None,
            }
        }
    }

    pub struct ShieldedTxBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ShieldedTxBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(ShieldedTx::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_tx_id(&mut self, tx_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedTx::VT_TX_ID, tx_id);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(ShieldedTx::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_short_tx_id(&mut self, short_tx_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ShieldedTx::VT_SHORT_TX_ID,
                short_tx_id,
            );
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedTx::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedTx::VT_NAME, name);
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_.push_slot::<u64>(ShieldedTx::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedTx::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_memo(&mut self, memo: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedTx::VT_MEMO, memo);
        }
        #[inline]
        pub fn add_messages(&mut self, messages: flatbuffers::WIPOffset<MemoVec<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<MemoVec>>(
                    ShieldedTx::VT_MESSAGES,
                    messages,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ShieldedTxBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ShieldedTxBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ShieldedTx<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ShieldedTx<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ShieldedTx");
            ds.field("id", &self.id());
            ds.field("tx_id", &self.tx_id());
            ds.field("height", &self.height());
            ds.field("short_tx_id", &self.short_tx_id());
            ds.field("timestamp", &self.timestamp());
            ds.field("name", &self.name());
            ds.field("value", &self.value());
            ds.field("address", &self.address());
            ds.field("memo", &self.memo());
            ds.field("messages", &self.messages());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ShieldedTxT {
        pub id: u32,
        pub tx_id: Option<String>,
        pub height: u32,
        pub short_tx_id: Option<String>,
        pub timestamp: u32,
        pub name: Option<String>,
        pub value: u64,
        pub address: Option<String>,
        pub memo: Option<String>,
        pub messages: Option<Box<MemoVecT>>,
    }
    impl Default for ShieldedTxT {
        fn default() -> Self {
            Self {
                id: 0,
                tx_id: None,
                height: 0,
                short_tx_id: None,
                timestamp: 0,
                name: None,
                value: 0,
                address: None,
                memo: None,
                messages: None,
            }
        }
    }
    impl ShieldedTxT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<ShieldedTx<'b>> {
            let id = self.id;
            let tx_id = self.tx_id.as_ref().map(|x| _fbb.create_string(x));
            let height = self.height;
            let short_tx_id = self.short_tx_id.as_ref().map(|x| _fbb.create_string(x));
            let timestamp = self.timestamp;
            let name = self.name.as_ref().map(|x| _fbb.create_string(x));
            let value = self.value;
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let memo = self.memo.as_ref().map(|x| _fbb.create_string(x));
            let messages = self.messages.as_ref().map(|x| x.pack(_fbb));
            ShieldedTx::create(
                _fbb,
                &ShieldedTxArgs {
                    id,
                    tx_id,
                    height,
                    short_tx_id,
                    timestamp,
                    name,
                    value,
                    address,
                    memo,
                    messages,
                },
            )
        }
    }
    pub enum ShieldedTxVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ShieldedTxVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ShieldedTxVec<'a> {
        type Inner = ShieldedTxVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ShieldedTxVec<'a> {
        pub const VT_TXS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ShieldedTxVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ShieldedTxVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<ShieldedTxVec<'bldr>> {
            let mut builder = ShieldedTxVecBuilder::new(_fbb);
            if let Some(x) = args.txs {
                builder.add_txs(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> ShieldedTxVecT {
            let txs = self.txs().map(|x| x.iter().map(|t| t.unpack()).collect());
            ShieldedTxVecT { txs }
        }

        #[inline]
        pub fn txs(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShieldedTx<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShieldedTx>>,
                >>(ShieldedTxVec::VT_TXS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for ShieldedTxVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ShieldedTx>>,
                >>("txs", Self::VT_TXS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ShieldedTxVecArgs<'a> {
        pub txs: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShieldedTx<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ShieldedTxVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            ShieldedTxVecArgs { txs: None }
        }
    }

    pub struct ShieldedTxVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ShieldedTxVecBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_txs(
            &mut self,
            txs: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ShieldedTx<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedTxVec::VT_TXS, txs);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ShieldedTxVecBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ShieldedTxVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ShieldedTxVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ShieldedTxVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ShieldedTxVec");
            ds.field("txs", &self.txs());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ShieldedTxVecT {
        pub txs: Option<Vec<ShieldedTxT>>,
    }
    impl Default for ShieldedTxVecT {
        fn default() -> Self {
            Self { txs: None }
        }
    }
    impl ShieldedTxVecT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<ShieldedTxVec<'b>> {
            let txs = self.txs.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            ShieldedTxVec::create(_fbb, &ShieldedTxVecArgs { txs })
        }
    }
    pub enum MessageOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Message<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Message<'a> {
        type Inner = Message<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Message<'a> {
        pub const VT_ID_MSG: flatbuffers::VOffsetT = 4;
        pub const VT_ID_TX: flatbuffers::VOffsetT = 6;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 8;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 10;
        pub const VT_SENDER: flatbuffers::VOffsetT = 12;
        pub const VT_FROM: flatbuffers::VOffsetT = 14;
        pub const VT_TO: flatbuffers::VOffsetT = 16;
        pub const VT_SUBJECT: flatbuffers::VOffsetT = 18;
        pub const VT_BODY: flatbuffers::VOffsetT = 20;
        pub const VT_READ: flatbuffers::VOffsetT = 22;
        pub const VT_INCOMING: flatbuffers::VOffsetT = 24;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Message { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args MessageArgs<'args>,
        ) -> flatbuffers::WIPOffset<Message<'bldr>> {
            let mut builder = MessageBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.subject {
                builder.add_subject(x);
            }
            if let Some(x) = args.to {
                builder.add_to(x);
            }
            if let Some(x) = args.from {
                builder.add_from(x);
            }
            if let Some(x) = args.sender {
                builder.add_sender(x);
            }
            builder.add_timestamp(args.timestamp);
            builder.add_height(args.height);
            builder.add_id_tx(args.id_tx);
            builder.add_id_msg(args.id_msg);
            builder.add_incoming(args.incoming);
            builder.add_read(args.read);
            builder.finish()
        }

        pub fn unpack(&self) -> MessageT {
            let id_msg = self.id_msg();
            let id_tx = self.id_tx();
            let height = self.height();
            let timestamp = self.timestamp();
            let sender = self.sender().map(|x| x.to_string());
            let from = self.from().map(|x| x.to_string());
            let to = self.to().map(|x| x.to_string());
            let subject = self.subject().map(|x| x.to_string());
            let body = self.body().map(|x| x.to_string());
            let read = self.read();
            let incoming = self.incoming();
            MessageT {
                id_msg,
                id_tx,
                height,
                timestamp,
                sender,
                from,
                to,
                subject,
                body,
                read,
                incoming,
            }
        }

        #[inline]
        pub fn id_msg(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Message::VT_ID_MSG, Some(0)).unwrap() }
        }
        #[inline]
        pub fn id_tx(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Message::VT_ID_TX, Some(0)).unwrap() }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Message::VT_HEIGHT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Message::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn sender(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Message::VT_SENDER, None)
            }
        }
        #[inline]
        pub fn from(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Message::VT_FROM, None)
            }
        }
        #[inline]
        pub fn to(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Message::VT_TO, None)
            }
        }
        #[inline]
        pub fn subject(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Message::VT_SUBJECT, None)
            }
        }
        #[inline]
        pub fn body(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Message::VT_BODY, None)
            }
        }
        #[inline]
        pub fn read(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Message::VT_READ, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn incoming(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Message::VT_INCOMING, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Message<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id_msg", Self::VT_ID_MSG, false)?
                .visit_field::<u32>("id_tx", Self::VT_ID_TX, false)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "sender",
                    Self::VT_SENDER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("from", Self::VT_FROM, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("to", Self::VT_TO, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "subject",
                    Self::VT_SUBJECT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("body", Self::VT_BODY, false)?
                .visit_field::<bool>("read", Self::VT_READ, false)?
                .visit_field::<bool>("incoming", Self::VT_INCOMING, false)?
                .finish();
            Ok(())
        }
    }
    pub struct MessageArgs<'a> {
        pub id_msg: u32,
        pub id_tx: u32,
        pub height: u32,
        pub timestamp: u32,
        pub sender: Option<flatbuffers::WIPOffset<&'a str>>,
        pub from: Option<flatbuffers::WIPOffset<&'a str>>,
        pub to: Option<flatbuffers::WIPOffset<&'a str>>,
        pub subject: Option<flatbuffers::WIPOffset<&'a str>>,
        pub body: Option<flatbuffers::WIPOffset<&'a str>>,
        pub read: bool,
        pub incoming: bool,
    }
    impl<'a> Default for MessageArgs<'a> {
        #[inline]
        fn default() -> Self {
            MessageArgs {
                id_msg: 0,
                id_tx: 0,
                height: 0,
                timestamp: 0,
                sender: None,
                from: None,
                to: None,
                subject: None,
                body: None,
                read: false,
                incoming: false,
            }
        }
    }

    pub struct MessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MessageBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id_msg(&mut self, id_msg: u32) {
            self.fbb_.push_slot::<u32>(Message::VT_ID_MSG, id_msg, 0);
        }
        #[inline]
        pub fn add_id_tx(&mut self, id_tx: u32) {
            self.fbb_.push_slot::<u32>(Message::VT_ID_TX, id_tx, 0);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(Message::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(Message::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_sender(&mut self, sender: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_SENDER, sender);
        }
        #[inline]
        pub fn add_from(&mut self, from: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_FROM, from);
        }
        #[inline]
        pub fn add_to(&mut self, to: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_TO, to);
        }
        #[inline]
        pub fn add_subject(&mut self, subject: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_SUBJECT, subject);
        }
        #[inline]
        pub fn add_body(&mut self, body: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_BODY, body);
        }
        #[inline]
        pub fn add_read(&mut self, read: bool) {
            self.fbb_.push_slot::<bool>(Message::VT_READ, read, false);
        }
        #[inline]
        pub fn add_incoming(&mut self, incoming: bool) {
            self.fbb_
                .push_slot::<bool>(Message::VT_INCOMING, incoming, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> MessageBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            MessageBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Message<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Message");
            ds.field("id_msg", &self.id_msg());
            ds.field("id_tx", &self.id_tx());
            ds.field("height", &self.height());
            ds.field("timestamp", &self.timestamp());
            ds.field("sender", &self.sender());
            ds.field("from", &self.from());
            ds.field("to", &self.to());
            ds.field("subject", &self.subject());
            ds.field("body", &self.body());
            ds.field("read", &self.read());
            ds.field("incoming", &self.incoming());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageT {
        pub id_msg: u32,
        pub id_tx: u32,
        pub height: u32,
        pub timestamp: u32,
        pub sender: Option<String>,
        pub from: Option<String>,
        pub to: Option<String>,
        pub subject: Option<String>,
        pub body: Option<String>,
        pub read: bool,
        pub incoming: bool,
    }
    impl Default for MessageT {
        fn default() -> Self {
            Self {
                id_msg: 0,
                id_tx: 0,
                height: 0,
                timestamp: 0,
                sender: None,
                from: None,
                to: None,
                subject: None,
                body: None,
                read: false,
                incoming: false,
            }
        }
    }
    impl MessageT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Message<'b>> {
            let id_msg = self.id_msg;
            let id_tx = self.id_tx;
            let height = self.height;
            let timestamp = self.timestamp;
            let sender = self.sender.as_ref().map(|x| _fbb.create_string(x));
            let from = self.from.as_ref().map(|x| _fbb.create_string(x));
            let to = self.to.as_ref().map(|x| _fbb.create_string(x));
            let subject = self.subject.as_ref().map(|x| _fbb.create_string(x));
            let body = self.body.as_ref().map(|x| _fbb.create_string(x));
            let read = self.read;
            let incoming = self.incoming;
            Message::create(
                _fbb,
                &MessageArgs {
                    id_msg,
                    id_tx,
                    height,
                    timestamp,
                    sender,
                    from,
                    to,
                    subject,
                    body,
                    read,
                    incoming,
                },
            )
        }
    }
    pub enum MessageVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MessageVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MessageVec<'a> {
        type Inner = MessageVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> MessageVec<'a> {
        pub const VT_MESSAGES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MessageVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args MessageVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<MessageVec<'bldr>> {
            let mut builder = MessageVecBuilder::new(_fbb);
            if let Some(x) = args.messages {
                builder.add_messages(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> MessageVecT {
            let messages = self
                .messages()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            MessageVecT { messages }
        }

        #[inline]
        pub fn messages(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Message<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Message>>,
                >>(MessageVec::VT_MESSAGES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for MessageVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Message>>,
                >>("messages", Self::VT_MESSAGES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct MessageVecArgs<'a> {
        pub messages: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Message<'a>>>,
            >,
        >,
    }
    impl<'a> Default for MessageVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            MessageVecArgs { messages: None }
        }
    }

    pub struct MessageVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MessageVecBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_messages(
            &mut self,
            messages: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Message<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MessageVec::VT_MESSAGES, messages);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> MessageVecBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            MessageVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MessageVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MessageVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MessageVec");
            ds.field("messages", &self.messages());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageVecT {
        pub messages: Option<Vec<MessageT>>,
    }
    impl Default for MessageVecT {
        fn default() -> Self {
            Self { messages: None }
        }
    }
    impl MessageVecT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<MessageVec<'b>> {
            let messages = self.messages.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            MessageVec::create(_fbb, &MessageVecArgs { messages })
        }
    }
    pub enum MemoOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Memo<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Memo<'a> {
        type Inner = Memo<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Memo<'a> {
        pub const VT_DIRECTION: flatbuffers::VOffsetT = 4;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 6;
        pub const VT_MEMO: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Memo { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args MemoArgs<'args>,
        ) -> flatbuffers::WIPOffset<Memo<'bldr>> {
            let mut builder = MemoBuilder::new(_fbb);
            if let Some(x) = args.memo {
                builder.add_memo(x);
            }
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.add_direction(args.direction);
            builder.finish()
        }

        pub fn unpack(&self) -> MemoT {
            let direction = self.direction();
            let address = self.address().map(|x| x.to_string());
            let memo = self.memo().map(|x| x.to_string());
            MemoT {
                direction,
                address,
                memo,
            }
        }

        #[inline]
        pub fn direction(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u8>(Memo::VT_DIRECTION, Some(0)).unwrap() }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Memo::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn memo(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Memo::VT_MEMO, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Memo<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u8>("direction", Self::VT_DIRECTION, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memo", Self::VT_MEMO, false)?
                .finish();
            Ok(())
        }
    }
    pub struct MemoArgs<'a> {
        pub direction: u8,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub memo: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for MemoArgs<'a> {
        #[inline]
        fn default() -> Self {
            MemoArgs {
                direction: 0,
                address: None,
                memo: None,
            }
        }
    }

    pub struct MemoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MemoBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_direction(&mut self, direction: u8) {
            self.fbb_.push_slot::<u8>(Memo::VT_DIRECTION, direction, 0);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Memo::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_memo(&mut self, memo: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Memo::VT_MEMO, memo);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MemoBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            MemoBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Memo<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Memo<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Memo");
            ds.field("direction", &self.direction());
            ds.field("address", &self.address());
            ds.field("memo", &self.memo());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct MemoT {
        pub direction: u8,
        pub address: Option<String>,
        pub memo: Option<String>,
    }
    impl Default for MemoT {
        fn default() -> Self {
            Self {
                direction: 0,
                address: None,
                memo: None,
            }
        }
    }
    impl MemoT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Memo<'b>> {
            let direction = self.direction;
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let memo = self.memo.as_ref().map(|x| _fbb.create_string(x));
            Memo::create(
                _fbb,
                &MemoArgs {
                    direction,
                    address,
                    memo,
                },
            )
        }
    }
    pub enum MemoVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MemoVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MemoVec<'a> {
        type Inner = MemoVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> MemoVec<'a> {
        pub const VT_MEMOS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MemoVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args MemoVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<MemoVec<'bldr>> {
            let mut builder = MemoVecBuilder::new(_fbb);
            if let Some(x) = args.memos {
                builder.add_memos(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> MemoVecT {
            let memos = self.memos().map(|x| x.iter().map(|t| t.unpack()).collect());
            MemoVecT { memos }
        }

        #[inline]
        pub fn memos(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Memo<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Memo>>,
                >>(MemoVec::VT_MEMOS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for MemoVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Memo>>,
                >>("memos", Self::VT_MEMOS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct MemoVecArgs<'a> {
        pub memos: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Memo<'a>>>>,
        >,
    }
    impl<'a> Default for MemoVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            MemoVecArgs { memos: None }
        }
    }

    pub struct MemoVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MemoVecBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_memos(
            &mut self,
            memos: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Memo<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MemoVec::VT_MEMOS, memos);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> MemoVecBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            MemoVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MemoVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MemoVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MemoVec");
            ds.field("memos", &self.memos());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct MemoVecT {
        pub memos: Option<Vec<MemoT>>,
    }
    impl Default for MemoVecT {
        fn default() -> Self {
            Self { memos: None }
        }
    }
    impl MemoVecT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<MemoVec<'b>> {
            let memos = self.memos.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            MemoVec::create(_fbb, &MemoVecArgs { memos })
        }
    }
    pub enum PrevNextOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PrevNext<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PrevNext<'a> {
        type Inner = PrevNext<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PrevNext<'a> {
        pub const VT_PREV: flatbuffers::VOffsetT = 4;
        pub const VT_NEXT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PrevNext { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args PrevNextArgs,
        ) -> flatbuffers::WIPOffset<PrevNext<'bldr>> {
            let mut builder = PrevNextBuilder::new(_fbb);
            builder.add_next(args.next);
            builder.add_prev(args.prev);
            builder.finish()
        }

        pub fn unpack(&self) -> PrevNextT {
            let prev = self.prev();
            let next = self.next();
            PrevNextT { prev, next }
        }

        #[inline]
        pub fn prev(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(PrevNext::VT_PREV, Some(0)).unwrap() }
        }
        #[inline]
        pub fn next(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(PrevNext::VT_NEXT, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for PrevNext<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("prev", Self::VT_PREV, false)?
                .visit_field::<u32>("next", Self::VT_NEXT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PrevNextArgs {
        pub prev: u32,
        pub next: u32,
    }
    impl<'a> Default for PrevNextArgs {
        #[inline]
        fn default() -> Self {
            PrevNextArgs { prev: 0, next: 0 }
        }
    }

    pub struct PrevNextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PrevNextBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_prev(&mut self, prev: u32) {
            self.fbb_.push_slot::<u32>(PrevNext::VT_PREV, prev, 0);
        }
        #[inline]
        pub fn add_next(&mut self, next: u32) {
            self.fbb_.push_slot::<u32>(PrevNext::VT_NEXT, next, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> PrevNextBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            PrevNextBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PrevNext<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PrevNext<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PrevNext");
            ds.field("prev", &self.prev());
            ds.field("next", &self.next());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrevNextT {
        pub prev: u32,
        pub next: u32,
    }
    impl Default for PrevNextT {
        fn default() -> Self {
            Self { prev: 0, next: 0 }
        }
    }
    impl PrevNextT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<PrevNext<'b>> {
            let prev = self.prev;
            let next = self.next;
            PrevNext::create(_fbb, &PrevNextArgs { prev, next })
        }
    }
    pub enum SendTemplateOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SendTemplate<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SendTemplate<'a> {
        type Inner = SendTemplate<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SendTemplate<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_TITLE: flatbuffers::VOffsetT = 6;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 8;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 10;
        pub const VT_FIAT_AMOUNT: flatbuffers::VOffsetT = 12;
        pub const VT_FEE_INCLUDED: flatbuffers::VOffsetT = 14;
        pub const VT_FIAT: flatbuffers::VOffsetT = 16;
        pub const VT_INCLUDE_REPLY_TO: flatbuffers::VOffsetT = 18;
        pub const VT_SUBJECT: flatbuffers::VOffsetT = 20;
        pub const VT_BODY: flatbuffers::VOffsetT = 22;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SendTemplate { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SendTemplateArgs<'args>,
        ) -> flatbuffers::WIPOffset<SendTemplate<'bldr>> {
            let mut builder = SendTemplateBuilder::new(_fbb);
            builder.add_fiat_amount(args.fiat_amount);
            builder.add_amount(args.amount);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.subject {
                builder.add_subject(x);
            }
            if let Some(x) = args.fiat {
                builder.add_fiat(x);
            }
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            if let Some(x) = args.title {
                builder.add_title(x);
            }
            builder.add_id(args.id);
            builder.add_include_reply_to(args.include_reply_to);
            builder.add_fee_included(args.fee_included);
            builder.finish()
        }

        pub fn unpack(&self) -> SendTemplateT {
            let id = self.id();
            let title = self.title().map(|x| x.to_string());
            let address = self.address().map(|x| x.to_string());
            let amount = self.amount();
            let fiat_amount = self.fiat_amount();
            let fee_included = self.fee_included();
            let fiat = self.fiat().map(|x| x.to_string());
            let include_reply_to = self.include_reply_to();
            let subject = self.subject().map(|x| x.to_string());
            let body = self.body().map(|x| x.to_string());
            SendTemplateT {
                id,
                title,
                address,
                amount,
                fiat_amount,
                fee_included,
                fiat,
                include_reply_to,
                subject,
                body,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(SendTemplate::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn title(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(SendTemplate::VT_TITLE, None)
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(SendTemplate::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(SendTemplate::VT_AMOUNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fiat_amount(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(SendTemplate::VT_FIAT_AMOUNT, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fee_included(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(SendTemplate::VT_FEE_INCLUDED, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fiat(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(SendTemplate::VT_FIAT, None)
            }
        }
        #[inline]
        pub fn include_reply_to(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(SendTemplate::VT_INCLUDE_REPLY_TO, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn subject(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(SendTemplate::VT_SUBJECT, None)
            }
        }
        #[inline]
        pub fn body(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(SendTemplate::VT_BODY, None)
            }
        }
    }

    impl flatbuffers::Verifiable for SendTemplate<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<f64>("fiat_amount", Self::VT_FIAT_AMOUNT, false)?
                .visit_field::<bool>("fee_included", Self::VT_FEE_INCLUDED, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fiat", Self::VT_FIAT, false)?
                .visit_field::<bool>("include_reply_to", Self::VT_INCLUDE_REPLY_TO, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "subject",
                    Self::VT_SUBJECT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("body", Self::VT_BODY, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SendTemplateArgs<'a> {
        pub id: u32,
        pub title: Option<flatbuffers::WIPOffset<&'a str>>,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub amount: u64,
        pub fiat_amount: f64,
        pub fee_included: bool,
        pub fiat: Option<flatbuffers::WIPOffset<&'a str>>,
        pub include_reply_to: bool,
        pub subject: Option<flatbuffers::WIPOffset<&'a str>>,
        pub body: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for SendTemplateArgs<'a> {
        #[inline]
        fn default() -> Self {
            SendTemplateArgs {
                id: 0,
                title: None,
                address: None,
                amount: 0,
                fiat_amount: 0.0,
                fee_included: false,
                fiat: None,
                include_reply_to: false,
                subject: None,
                body: None,
            }
        }
    }

    pub struct SendTemplateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SendTemplateBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(SendTemplate::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SendTemplate::VT_TITLE, title);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SendTemplate::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_
                .push_slot::<u64>(SendTemplate::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_fiat_amount(&mut self, fiat_amount: f64) {
            self.fbb_
                .push_slot::<f64>(SendTemplate::VT_FIAT_AMOUNT, fiat_amount, 0.0);
        }
        #[inline]
        pub fn add_fee_included(&mut self, fee_included: bool) {
            self.fbb_
                .push_slot::<bool>(SendTemplate::VT_FEE_INCLUDED, fee_included, false);
        }
        #[inline]
        pub fn add_fiat(&mut self, fiat: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SendTemplate::VT_FIAT, fiat);
        }
        #[inline]
        pub fn add_include_reply_to(&mut self, include_reply_to: bool) {
            self.fbb_
                .push_slot::<bool>(SendTemplate::VT_INCLUDE_REPLY_TO, include_reply_to, false);
        }
        #[inline]
        pub fn add_subject(&mut self, subject: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SendTemplate::VT_SUBJECT, subject);
        }
        #[inline]
        pub fn add_body(&mut self, body: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SendTemplate::VT_BODY, body);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SendTemplateBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SendTemplateBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SendTemplate<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SendTemplate<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SendTemplate");
            ds.field("id", &self.id());
            ds.field("title", &self.title());
            ds.field("address", &self.address());
            ds.field("amount", &self.amount());
            ds.field("fiat_amount", &self.fiat_amount());
            ds.field("fee_included", &self.fee_included());
            ds.field("fiat", &self.fiat());
            ds.field("include_reply_to", &self.include_reply_to());
            ds.field("subject", &self.subject());
            ds.field("body", &self.body());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendTemplateT {
        pub id: u32,
        pub title: Option<String>,
        pub address: Option<String>,
        pub amount: u64,
        pub fiat_amount: f64,
        pub fee_included: bool,
        pub fiat: Option<String>,
        pub include_reply_to: bool,
        pub subject: Option<String>,
        pub body: Option<String>,
    }
    impl Default for SendTemplateT {
        fn default() -> Self {
            Self {
                id: 0,
                title: None,
                address: None,
                amount: 0,
                fiat_amount: 0.0,
                fee_included: false,
                fiat: None,
                include_reply_to: false,
                subject: None,
                body: None,
            }
        }
    }
    impl SendTemplateT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<SendTemplate<'b>> {
            let id = self.id;
            let title = self.title.as_ref().map(|x| _fbb.create_string(x));
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let amount = self.amount;
            let fiat_amount = self.fiat_amount;
            let fee_included = self.fee_included;
            let fiat = self.fiat.as_ref().map(|x| _fbb.create_string(x));
            let include_reply_to = self.include_reply_to;
            let subject = self.subject.as_ref().map(|x| _fbb.create_string(x));
            let body = self.body.as_ref().map(|x| _fbb.create_string(x));
            SendTemplate::create(
                _fbb,
                &SendTemplateArgs {
                    id,
                    title,
                    address,
                    amount,
                    fiat_amount,
                    fee_included,
                    fiat,
                    include_reply_to,
                    subject,
                    body,
                },
            )
        }
    }
    pub enum SendTemplateVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SendTemplateVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SendTemplateVec<'a> {
        type Inner = SendTemplateVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SendTemplateVec<'a> {
        pub const VT_TEMPLATES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SendTemplateVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SendTemplateVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<SendTemplateVec<'bldr>> {
            let mut builder = SendTemplateVecBuilder::new(_fbb);
            if let Some(x) = args.templates {
                builder.add_templates(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> SendTemplateVecT {
            let templates = self
                .templates()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            SendTemplateVecT { templates }
        }

        #[inline]
        pub fn templates(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SendTemplate<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SendTemplate>>,
                >>(SendTemplateVec::VT_TEMPLATES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for SendTemplateVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SendTemplate>>,
                >>("templates", Self::VT_TEMPLATES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SendTemplateVecArgs<'a> {
        pub templates: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SendTemplate<'a>>>,
            >,
        >,
    }
    impl<'a> Default for SendTemplateVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            SendTemplateVecArgs { templates: None }
        }
    }

    pub struct SendTemplateVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SendTemplateVecBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_templates(
            &mut self,
            templates: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SendTemplate<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SendTemplateVec::VT_TEMPLATES,
                templates,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SendTemplateVecBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SendTemplateVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SendTemplateVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SendTemplateVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SendTemplateVec");
            ds.field("templates", &self.templates());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendTemplateVecT {
        pub templates: Option<Vec<SendTemplateT>>,
    }
    impl Default for SendTemplateVecT {
        fn default() -> Self {
            Self { templates: None }
        }
    }
    impl SendTemplateVecT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<SendTemplateVec<'b>> {
            let templates = self.templates.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            SendTemplateVec::create(_fbb, &SendTemplateVecArgs { templates })
        }
    }
    pub enum ContactOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Contact<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Contact<'a> {
        type Inner = Contact<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Contact<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Contact { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ContactArgs<'args>,
        ) -> flatbuffers::WIPOffset<Contact<'bldr>> {
            let mut builder = ContactBuilder::new(_fbb);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_id(args.id);
            builder.finish()
        }

        pub fn unpack(&self) -> ContactT {
            let id = self.id();
            let name = self.name().map(|x| x.to_string());
            let address = self.address().map(|x| x.to_string());
            ContactT { id, name, address }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Contact::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Contact::VT_NAME, None)
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Contact::VT_ADDRESS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Contact<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ContactArgs<'a> {
        pub id: u32,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for ContactArgs<'a> {
        #[inline]
        fn default() -> Self {
            ContactArgs {
                id: 0,
                name: None,
                address: None,
            }
        }
    }

    pub struct ContactBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContactBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(Contact::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Contact::VT_NAME, name);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Contact::VT_ADDRESS, address);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ContactBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ContactBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Contact<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Contact<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Contact");
            ds.field("id", &self.id());
            ds.field("name", &self.name());
            ds.field("address", &self.address());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ContactT {
        pub id: u32,
        pub name: Option<String>,
        pub address: Option<String>,
    }
    impl Default for ContactT {
        fn default() -> Self {
            Self {
                id: 0,
                name: None,
                address: None,
            }
        }
    }
    impl ContactT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Contact<'b>> {
            let id = self.id;
            let name = self.name.as_ref().map(|x| _fbb.create_string(x));
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            Contact::create(_fbb, &ContactArgs { id, name, address })
        }
    }
    pub enum ContactVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ContactVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ContactVec<'a> {
        type Inner = ContactVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ContactVec<'a> {
        pub const VT_CONTACTS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ContactVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ContactVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<ContactVec<'bldr>> {
            let mut builder = ContactVecBuilder::new(_fbb);
            if let Some(x) = args.contacts {
                builder.add_contacts(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> ContactVecT {
            let contacts = self
                .contacts()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            ContactVecT { contacts }
        }

        #[inline]
        pub fn contacts(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Contact<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Contact>>,
                >>(ContactVec::VT_CONTACTS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for ContactVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Contact>>,
                >>("contacts", Self::VT_CONTACTS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ContactVecArgs<'a> {
        pub contacts: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Contact<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ContactVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            ContactVecArgs { contacts: None }
        }
    }

    pub struct ContactVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContactVecBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_contacts(
            &mut self,
            contacts: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Contact<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ContactVec::VT_CONTACTS, contacts);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ContactVecBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ContactVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ContactVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ContactVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ContactVec");
            ds.field("contacts", &self.contacts());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ContactVecT {
        pub contacts: Option<Vec<ContactT>>,
    }
    impl Default for ContactVecT {
        fn default() -> Self {
            Self { contacts: None }
        }
    }
    impl ContactVecT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<ContactVec<'b>> {
            let contacts = self.contacts.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            ContactVec::create(_fbb, &ContactVecArgs { contacts })
        }
    }
    pub enum TxTimeValueOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TxTimeValue<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TxTimeValue<'a> {
        type Inner = TxTimeValue<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TxTimeValue<'a> {
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TxTimeValue { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TxTimeValueArgs,
        ) -> flatbuffers::WIPOffset<TxTimeValue<'bldr>> {
            let mut builder = TxTimeValueBuilder::new(_fbb);
            builder.add_value(args.value);
            builder.add_timestamp(args.timestamp);
            builder.finish()
        }

        pub fn unpack(&self) -> TxTimeValueT {
            let timestamp = self.timestamp();
            let value = self.value();
            TxTimeValueT { timestamp, value }
        }

        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TxTimeValue::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn value(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(TxTimeValue::VT_VALUE, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for TxTimeValue<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<i64>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TxTimeValueArgs {
        pub timestamp: u32,
        pub value: i64,
    }
    impl<'a> Default for TxTimeValueArgs {
        #[inline]
        fn default() -> Self {
            TxTimeValueArgs {
                timestamp: 0,
                value: 0,
            }
        }
    }

    pub struct TxTimeValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TxTimeValueBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(TxTimeValue::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_value(&mut self, value: i64) {
            self.fbb_.push_slot::<i64>(TxTimeValue::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TxTimeValueBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TxTimeValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TxTimeValue<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TxTimeValue<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TxTimeValue");
            ds.field("timestamp", &self.timestamp());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TxTimeValueT {
        pub timestamp: u32,
        pub value: i64,
    }
    impl Default for TxTimeValueT {
        fn default() -> Self {
            Self {
                timestamp: 0,
                value: 0,
            }
        }
    }
    impl TxTimeValueT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TxTimeValue<'b>> {
            let timestamp = self.timestamp;
            let value = self.value;
            TxTimeValue::create(_fbb, &TxTimeValueArgs { timestamp, value })
        }
    }
    pub enum TxTimeValueVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TxTimeValueVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TxTimeValueVec<'a> {
        type Inner = TxTimeValueVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TxTimeValueVec<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TxTimeValueVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TxTimeValueVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<TxTimeValueVec<'bldr>> {
            let mut builder = TxTimeValueVecBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> TxTimeValueVecT {
            let values = self
                .values()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            TxTimeValueVecT { values }
        }

        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TxTimeValue<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TxTimeValue>>,
                >>(TxTimeValueVec::VT_VALUES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for TxTimeValueVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TxTimeValue>>,
                >>("values", Self::VT_VALUES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TxTimeValueVecArgs<'a> {
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TxTimeValue<'a>>>,
            >,
        >,
    }
    impl<'a> Default for TxTimeValueVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            TxTimeValueVecArgs { values: None }
        }
    }

    pub struct TxTimeValueVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TxTimeValueVecBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TxTimeValue<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TxTimeValueVec::VT_VALUES, values);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TxTimeValueVecBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TxTimeValueVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TxTimeValueVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TxTimeValueVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TxTimeValueVec");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TxTimeValueVecT {
        pub values: Option<Vec<TxTimeValueT>>,
    }
    impl Default for TxTimeValueVecT {
        fn default() -> Self {
            Self { values: None }
        }
    }
    impl TxTimeValueVecT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TxTimeValueVec<'b>> {
            let values = self.values.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            TxTimeValueVec::create(_fbb, &TxTimeValueVecArgs { values })
        }
    }
    pub enum QuoteOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Quote<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Quote<'a> {
        type Inner = Quote<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Quote<'a> {
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 4;
        pub const VT_PRICE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Quote { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args QuoteArgs,
        ) -> flatbuffers::WIPOffset<Quote<'bldr>> {
            let mut builder = QuoteBuilder::new(_fbb);
            builder.add_price(args.price);
            builder.add_timestamp(args.timestamp);
            builder.finish()
        }

        pub fn unpack(&self) -> QuoteT {
            let timestamp = self.timestamp();
            let price = self.price();
            QuoteT { timestamp, price }
        }

        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Quote::VT_TIMESTAMP, Some(0)).unwrap() }
        }
        #[inline]
        pub fn price(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<f64>(Quote::VT_PRICE, Some(0.0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Quote<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<f64>("price", Self::VT_PRICE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct QuoteArgs {
        pub timestamp: u32,
        pub price: f64,
    }
    impl<'a> Default for QuoteArgs {
        #[inline]
        fn default() -> Self {
            QuoteArgs {
                timestamp: 0,
                price: 0.0,
            }
        }
    }

    pub struct QuoteBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> QuoteBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(Quote::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_price(&mut self, price: f64) {
            self.fbb_.push_slot::<f64>(Quote::VT_PRICE, price, 0.0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> QuoteBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            QuoteBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Quote<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Quote<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Quote");
            ds.field("timestamp", &self.timestamp());
            ds.field("price", &self.price());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct QuoteT {
        pub timestamp: u32,
        pub price: f64,
    }
    impl Default for QuoteT {
        fn default() -> Self {
            Self {
                timestamp: 0,
                price: 0.0,
            }
        }
    }
    impl QuoteT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Quote<'b>> {
            let timestamp = self.timestamp;
            let price = self.price;
            Quote::create(_fbb, &QuoteArgs { timestamp, price })
        }
    }
    pub enum QuoteVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct QuoteVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for QuoteVec<'a> {
        type Inner = QuoteVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> QuoteVec<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            QuoteVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args QuoteVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<QuoteVec<'bldr>> {
            let mut builder = QuoteVecBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> QuoteVecT {
            let values = self
                .values()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            QuoteVecT { values }
        }

        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Quote<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Quote>>,
                >>(QuoteVec::VT_VALUES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for QuoteVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Quote>>,
                >>("values", Self::VT_VALUES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct QuoteVecArgs<'a> {
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Quote<'a>>>,
            >,
        >,
    }
    impl<'a> Default for QuoteVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            QuoteVecArgs { values: None }
        }
    }

    pub struct QuoteVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> QuoteVecBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Quote<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(QuoteVec::VT_VALUES, values);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> QuoteVecBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            QuoteVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<QuoteVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for QuoteVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("QuoteVec");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct QuoteVecT {
        pub values: Option<Vec<QuoteT>>,
    }
    impl Default for QuoteVecT {
        fn default() -> Self {
            Self { values: None }
        }
    }
    impl QuoteVecT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<QuoteVec<'b>> {
            let values = self.values.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            QuoteVec::create(_fbb, &QuoteVecArgs { values })
        }
    }
    pub enum SpendingOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Spending<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Spending<'a> {
        type Inner = Spending<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Spending<'a> {
        pub const VT_RECIPIENT: flatbuffers::VOffsetT = 4;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Spending { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SpendingArgs<'args>,
        ) -> flatbuffers::WIPOffset<Spending<'bldr>> {
            let mut builder = SpendingBuilder::new(_fbb);
            builder.add_amount(args.amount);
            if let Some(x) = args.recipient {
                builder.add_recipient(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> SpendingT {
            let recipient = self.recipient().map(|x| x.to_string());
            let amount = self.amount();
            SpendingT { recipient, amount }
        }

        #[inline]
        pub fn recipient(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Spending::VT_RECIPIENT, None)
            }
        }
        #[inline]
        pub fn amount(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i64>(Spending::VT_AMOUNT, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Spending<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "recipient",
                    Self::VT_RECIPIENT,
                    false,
                )?
                .visit_field::<i64>("amount", Self::VT_AMOUNT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SpendingArgs<'a> {
        pub recipient: Option<flatbuffers::WIPOffset<&'a str>>,
        pub amount: i64,
    }
    impl<'a> Default for SpendingArgs<'a> {
        #[inline]
        fn default() -> Self {
            SpendingArgs {
                recipient: None,
                amount: 0,
            }
        }
    }

    pub struct SpendingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SpendingBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_recipient(&mut self, recipient: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Spending::VT_RECIPIENT, recipient);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: i64) {
            self.fbb_.push_slot::<i64>(Spending::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SpendingBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SpendingBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Spending<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Spending<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Spending");
            ds.field("recipient", &self.recipient());
            ds.field("amount", &self.amount());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct SpendingT {
        pub recipient: Option<String>,
        pub amount: i64,
    }
    impl Default for SpendingT {
        fn default() -> Self {
            Self {
                recipient: None,
                amount: 0,
            }
        }
    }
    impl SpendingT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Spending<'b>> {
            let recipient = self.recipient.as_ref().map(|x| _fbb.create_string(x));
            let amount = self.amount;
            Spending::create(_fbb, &SpendingArgs { recipient, amount })
        }
    }
    pub enum SpendingVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SpendingVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SpendingVec<'a> {
        type Inner = SpendingVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SpendingVec<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SpendingVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SpendingVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<SpendingVec<'bldr>> {
            let mut builder = SpendingVecBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> SpendingVecT {
            let values = self
                .values()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            SpendingVecT { values }
        }

        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spending<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spending>>,
                >>(SpendingVec::VT_VALUES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for SpendingVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Spending>>,
                >>("values", Self::VT_VALUES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SpendingVecArgs<'a> {
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spending<'a>>>,
            >,
        >,
    }
    impl<'a> Default for SpendingVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            SpendingVecArgs { values: None }
        }
    }

    pub struct SpendingVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SpendingVecBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Spending<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SpendingVec::VT_VALUES, values);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SpendingVecBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SpendingVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SpendingVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SpendingVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SpendingVec");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct SpendingVecT {
        pub values: Option<Vec<SpendingT>>,
    }
    impl Default for SpendingVecT {
        fn default() -> Self {
            Self { values: None }
        }
    }
    impl SpendingVecT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<SpendingVec<'b>> {
            let values = self.values.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            SpendingVec::create(_fbb, &SpendingVecArgs { values })
        }
    }
    pub enum AddressBalanceOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AddressBalance<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AddressBalance<'a> {
        type Inner = AddressBalance<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AddressBalance<'a> {
        pub const VT_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 6;
        pub const VT_BALANCE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AddressBalance { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AddressBalanceArgs<'args>,
        ) -> flatbuffers::WIPOffset<AddressBalance<'bldr>> {
            let mut builder = AddressBalanceBuilder::new(_fbb);
            builder.add_balance(args.balance);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.add_index(args.index);
            builder.finish()
        }

        pub fn unpack(&self) -> AddressBalanceT {
            let index = self.index();
            let address = self.address().map(|x| x.to_string());
            let balance = self.balance();
            AddressBalanceT {
                index,
                address,
                balance,
            }
        }

        #[inline]
        pub fn index(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(AddressBalance::VT_INDEX, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AddressBalance::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn balance(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(AddressBalance::VT_BALANCE, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for AddressBalance<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("index", Self::VT_INDEX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u64>("balance", Self::VT_BALANCE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AddressBalanceArgs<'a> {
        pub index: u32,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub balance: u64,
    }
    impl<'a> Default for AddressBalanceArgs<'a> {
        #[inline]
        fn default() -> Self {
            AddressBalanceArgs {
                index: 0,
                address: None,
                balance: 0,
            }
        }
    }

    pub struct AddressBalanceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AddressBalanceBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_index(&mut self, index: u32) {
            self.fbb_
                .push_slot::<u32>(AddressBalance::VT_INDEX, index, 0);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AddressBalance::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_balance(&mut self, balance: u64) {
            self.fbb_
                .push_slot::<u64>(AddressBalance::VT_BALANCE, balance, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AddressBalanceBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AddressBalanceBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AddressBalance<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AddressBalance<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AddressBalance");
            ds.field("index", &self.index());
            ds.field("address", &self.address());
            ds.field("balance", &self.balance());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct AddressBalanceT {
        pub index: u32,
        pub address: Option<String>,
        pub balance: u64,
    }
    impl Default for AddressBalanceT {
        fn default() -> Self {
            Self {
                index: 0,
                address: None,
                balance: 0,
            }
        }
    }
    impl AddressBalanceT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<AddressBalance<'b>> {
            let index = self.index;
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let balance = self.balance;
            AddressBalance::create(
                _fbb,
                &AddressBalanceArgs {
                    index,
                    address,
                    balance,
                },
            )
        }
    }
    pub enum AddressBalanceVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AddressBalanceVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AddressBalanceVec<'a> {
        type Inner = AddressBalanceVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AddressBalanceVec<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AddressBalanceVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AddressBalanceVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<AddressBalanceVec<'bldr>> {
            let mut builder = AddressBalanceVecBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> AddressBalanceVecT {
            let values = self
                .values()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            AddressBalanceVecT { values }
        }

        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AddressBalance<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AddressBalance>>,
                >>(AddressBalanceVec::VT_VALUES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for AddressBalanceVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AddressBalance>>,
                >>("values", Self::VT_VALUES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AddressBalanceVecArgs<'a> {
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AddressBalance<'a>>>,
            >,
        >,
    }
    impl<'a> Default for AddressBalanceVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            AddressBalanceVecArgs { values: None }
        }
    }

    pub struct AddressBalanceVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AddressBalanceVecBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AddressBalance<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                AddressBalanceVec::VT_VALUES,
                values,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AddressBalanceVecBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AddressBalanceVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AddressBalanceVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AddressBalanceVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AddressBalanceVec");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct AddressBalanceVecT {
        pub values: Option<Vec<AddressBalanceT>>,
    }
    impl Default for AddressBalanceVecT {
        fn default() -> Self {
            Self { values: None }
        }
    }
    impl AddressBalanceVecT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<AddressBalanceVec<'b>> {
            let values = self.values.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            AddressBalanceVec::create(_fbb, &AddressBalanceVecArgs { values })
        }
    }
    pub enum CheckpointOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Checkpoint<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Checkpoint<'a> {
        type Inner = Checkpoint<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Checkpoint<'a> {
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Checkpoint { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args CheckpointArgs,
        ) -> flatbuffers::WIPOffset<Checkpoint<'bldr>> {
            let mut builder = CheckpointBuilder::new(_fbb);
            builder.add_timestamp(args.timestamp);
            builder.add_height(args.height);
            builder.finish()
        }

        pub fn unpack(&self) -> CheckpointT {
            let height = self.height();
            let timestamp = self.timestamp();
            CheckpointT { height, timestamp }
        }

        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Checkpoint::VT_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Checkpoint::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Checkpoint<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .finish();
            Ok(())
        }
    }
    pub struct CheckpointArgs {
        pub height: u32,
        pub timestamp: u32,
    }
    impl<'a> Default for CheckpointArgs {
        #[inline]
        fn default() -> Self {
            CheckpointArgs {
                height: 0,
                timestamp: 0,
            }
        }
    }

    pub struct CheckpointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CheckpointBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(Checkpoint::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(Checkpoint::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> CheckpointBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            CheckpointBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Checkpoint<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Checkpoint<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Checkpoint");
            ds.field("height", &self.height());
            ds.field("timestamp", &self.timestamp());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct CheckpointT {
        pub height: u32,
        pub timestamp: u32,
    }
    impl Default for CheckpointT {
        fn default() -> Self {
            Self {
                height: 0,
                timestamp: 0,
            }
        }
    }
    impl CheckpointT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Checkpoint<'b>> {
            let height = self.height;
            let timestamp = self.timestamp;
            Checkpoint::create(_fbb, &CheckpointArgs { height, timestamp })
        }
    }
    pub enum CheckpointVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CheckpointVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CheckpointVec<'a> {
        type Inner = CheckpointVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CheckpointVec<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CheckpointVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args CheckpointVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<CheckpointVec<'bldr>> {
            let mut builder = CheckpointVecBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> CheckpointVecT {
            let values = self
                .values()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            CheckpointVecT { values }
        }

        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Checkpoint<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Checkpoint>>,
                >>(CheckpointVec::VT_VALUES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for CheckpointVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Checkpoint>>,
                >>("values", Self::VT_VALUES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct CheckpointVecArgs<'a> {
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Checkpoint<'a>>>,
            >,
        >,
    }
    impl<'a> Default for CheckpointVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            CheckpointVecArgs { values: None }
        }
    }

    pub struct CheckpointVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CheckpointVecBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Checkpoint<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CheckpointVec::VT_VALUES, values);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> CheckpointVecBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            CheckpointVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CheckpointVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CheckpointVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CheckpointVec");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct CheckpointVecT {
        pub values: Option<Vec<CheckpointT>>,
    }
    impl Default for CheckpointVecT {
        fn default() -> Self {
            Self { values: None }
        }
    }
    impl CheckpointVecT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<CheckpointVec<'b>> {
            let values = self.values.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            CheckpointVec::create(_fbb, &CheckpointVecArgs { values })
        }
    }
    pub enum BackupOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Backup<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Backup<'a> {
        type Inner = Backup<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Backup<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_SEED: flatbuffers::VOffsetT = 6;
        pub const VT_INDEX: flatbuffers::VOffsetT = 8;
        pub const VT_SK: flatbuffers::VOffsetT = 10;
        pub const VT_FVK: flatbuffers::VOffsetT = 12;
        pub const VT_UVK: flatbuffers::VOffsetT = 14;
        pub const VT_TSK: flatbuffers::VOffsetT = 16;
        pub const VT_SAVED: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Backup { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BackupArgs<'args>,
        ) -> flatbuffers::WIPOffset<Backup<'bldr>> {
            let mut builder = BackupBuilder::new(_fbb);
            if let Some(x) = args.tsk {
                builder.add_tsk(x);
            }
            if let Some(x) = args.uvk {
                builder.add_uvk(x);
            }
            if let Some(x) = args.fvk {
                builder.add_fvk(x);
            }
            if let Some(x) = args.sk {
                builder.add_sk(x);
            }
            builder.add_index(args.index);
            if let Some(x) = args.seed {
                builder.add_seed(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_saved(args.saved);
            builder.finish()
        }

        pub fn unpack(&self) -> BackupT {
            let name = self.name().map(|x| x.to_string());
            let seed = self.seed().map(|x| x.to_string());
            let index = self.index();
            let sk = self.sk().map(|x| x.to_string());
            let fvk = self.fvk().map(|x| x.to_string());
            let uvk = self.uvk().map(|x| x.to_string());
            let tsk = self.tsk().map(|x| x.to_string());
            let saved = self.saved();
            BackupT {
                name,
                seed,
                index,
                sk,
                fvk,
                uvk,
                tsk,
                saved,
            }
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_NAME, None)
            }
        }
        #[inline]
        pub fn seed(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_SEED, None)
            }
        }
        #[inline]
        pub fn index(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Backup::VT_INDEX, Some(0)).unwrap() }
        }
        #[inline]
        pub fn sk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_SK, None)
            }
        }
        #[inline]
        pub fn fvk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_FVK, None)
            }
        }
        #[inline]
        pub fn uvk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_UVK, None)
            }
        }
        #[inline]
        pub fn tsk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_TSK, None)
            }
        }
        #[inline]
        pub fn saved(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Backup::VT_SAVED, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Backup<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("seed", Self::VT_SEED, false)?
                .visit_field::<u32>("index", Self::VT_INDEX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sk", Self::VT_SK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fvk", Self::VT_FVK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("uvk", Self::VT_UVK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tsk", Self::VT_TSK, false)?
                .visit_field::<bool>("saved", Self::VT_SAVED, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BackupArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub seed: Option<flatbuffers::WIPOffset<&'a str>>,
        pub index: u32,
        pub sk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub fvk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub uvk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub tsk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub saved: bool,
    }
    impl<'a> Default for BackupArgs<'a> {
        #[inline]
        fn default() -> Self {
            BackupArgs {
                name: None,
                seed: None,
                index: 0,
                sk: None,
                fvk: None,
                uvk: None,
                tsk: None,
                saved: false,
            }
        }
    }

    pub struct BackupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BackupBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_NAME, name);
        }
        #[inline]
        pub fn add_seed(&mut self, seed: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_SEED, seed);
        }
        #[inline]
        pub fn add_index(&mut self, index: u32) {
            self.fbb_.push_slot::<u32>(Backup::VT_INDEX, index, 0);
        }
        #[inline]
        pub fn add_sk(&mut self, sk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_SK, sk);
        }
        #[inline]
        pub fn add_fvk(&mut self, fvk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_FVK, fvk);
        }
        #[inline]
        pub fn add_uvk(&mut self, uvk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_UVK, uvk);
        }
        #[inline]
        pub fn add_tsk(&mut self, tsk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_TSK, tsk);
        }
        #[inline]
        pub fn add_saved(&mut self, saved: bool) {
            self.fbb_.push_slot::<bool>(Backup::VT_SAVED, saved, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> BackupBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BackupBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Backup<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Backup<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Backup");
            ds.field("name", &self.name());
            ds.field("seed", &self.seed());
            ds.field("index", &self.index());
            ds.field("sk", &self.sk());
            ds.field("fvk", &self.fvk());
            ds.field("uvk", &self.uvk());
            ds.field("tsk", &self.tsk());
            ds.field("saved", &self.saved());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct BackupT {
        pub name: Option<String>,
        pub seed: Option<String>,
        pub index: u32,
        pub sk: Option<String>,
        pub fvk: Option<String>,
        pub uvk: Option<String>,
        pub tsk: Option<String>,
        pub saved: bool,
    }
    impl Default for BackupT {
        fn default() -> Self {
            Self {
                name: None,
                seed: None,
                index: 0,
                sk: None,
                fvk: None,
                uvk: None,
                tsk: None,
                saved: false,
            }
        }
    }
    impl BackupT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Backup<'b>> {
            let name = self.name.as_ref().map(|x| _fbb.create_string(x));
            let seed = self.seed.as_ref().map(|x| _fbb.create_string(x));
            let index = self.index;
            let sk = self.sk.as_ref().map(|x| _fbb.create_string(x));
            let fvk = self.fvk.as_ref().map(|x| _fbb.create_string(x));
            let uvk = self.uvk.as_ref().map(|x| _fbb.create_string(x));
            let tsk = self.tsk.as_ref().map(|x| _fbb.create_string(x));
            let saved = self.saved;
            Backup::create(
                _fbb,
                &BackupArgs {
                    name,
                    seed,
                    index,
                    sk,
                    fvk,
                    uvk,
                    tsk,
                    saved,
                },
            )
        }
    }
    pub enum RaptorQDropsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RaptorQDrops<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RaptorQDrops<'a> {
        type Inner = RaptorQDrops<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> RaptorQDrops<'a> {
        pub const VT_DROPS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RaptorQDrops { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args RaptorQDropsArgs<'args>,
        ) -> flatbuffers::WIPOffset<RaptorQDrops<'bldr>> {
            let mut builder = RaptorQDropsBuilder::new(_fbb);
            if let Some(x) = args.drops {
                builder.add_drops(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> RaptorQDropsT {
            let drops = self
                .drops()
                .map(|x| x.iter().map(|s| s.to_string()).collect());
            RaptorQDropsT { drops }
        }

        #[inline]
        pub fn drops(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(RaptorQDrops::VT_DROPS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for RaptorQDrops<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("drops", Self::VT_DROPS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RaptorQDropsArgs<'a> {
        pub drops: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
    }
    impl<'a> Default for RaptorQDropsArgs<'a> {
        #[inline]
        fn default() -> Self {
            RaptorQDropsArgs { drops: None }
        }
    }

    pub struct RaptorQDropsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RaptorQDropsBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_drops(
            &mut self,
            drops: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(RaptorQDrops::VT_DROPS, drops);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> RaptorQDropsBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            RaptorQDropsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RaptorQDrops<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RaptorQDrops<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RaptorQDrops");
            ds.field("drops", &self.drops());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct RaptorQDropsT {
        pub drops: Option<Vec<String>>,
    }
    impl Default for RaptorQDropsT {
        fn default() -> Self {
            Self { drops: None }
        }
    }
    impl RaptorQDropsT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<RaptorQDrops<'b>> {
            let drops = self.drops.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
                _fbb.create_vector(&w)
            });
            RaptorQDrops::create(_fbb, &RaptorQDropsArgs { drops })
        }
    }
    pub enum RaptorQResultOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RaptorQResult<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RaptorQResult<'a> {
        type Inner = RaptorQResult<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> RaptorQResult<'a> {
        pub const VT_PROGRESS: flatbuffers::VOffsetT = 4;
        pub const VT_TOTAL: flatbuffers::VOffsetT = 6;
        pub const VT_DATA: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RaptorQResult { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args RaptorQResultArgs<'args>,
        ) -> flatbuffers::WIPOffset<RaptorQResult<'bldr>> {
            let mut builder = RaptorQResultBuilder::new(_fbb);
            if let Some(x) = args.data {
                builder.add_data(x);
            }
            builder.add_total(args.total);
            builder.add_progress(args.progress);
            builder.finish()
        }

        pub fn unpack(&self) -> RaptorQResultT {
            let progress = self.progress();
            let total = self.total();
            let data = self.data().map(|x| x.to_string());
            RaptorQResultT {
                progress,
                total,
                data,
            }
        }

        #[inline]
        pub fn progress(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(RaptorQResult::VT_PROGRESS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn total(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(RaptorQResult::VT_TOTAL, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn data(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(RaptorQResult::VT_DATA, None)
            }
        }
    }

    impl flatbuffers::Verifiable for RaptorQResult<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u8>("progress", Self::VT_PROGRESS, false)?
                .visit_field::<u8>("total", Self::VT_TOTAL, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("data", Self::VT_DATA, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RaptorQResultArgs<'a> {
        pub progress: u8,
        pub total: u8,
        pub data: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for RaptorQResultArgs<'a> {
        #[inline]
        fn default() -> Self {
            RaptorQResultArgs {
                progress: 0,
                total: 0,
                data: None,
            }
        }
    }

    pub struct RaptorQResultBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RaptorQResultBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_progress(&mut self, progress: u8) {
            self.fbb_
                .push_slot::<u8>(RaptorQResult::VT_PROGRESS, progress, 0);
        }
        #[inline]
        pub fn add_total(&mut self, total: u8) {
            self.fbb_.push_slot::<u8>(RaptorQResult::VT_TOTAL, total, 0);
        }
        #[inline]
        pub fn add_data(&mut self, data: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(RaptorQResult::VT_DATA, data);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> RaptorQResultBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            RaptorQResultBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RaptorQResult<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RaptorQResult<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RaptorQResult");
            ds.field("progress", &self.progress());
            ds.field("total", &self.total());
            ds.field("data", &self.data());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct RaptorQResultT {
        pub progress: u8,
        pub total: u8,
        pub data: Option<String>,
    }
    impl Default for RaptorQResultT {
        fn default() -> Self {
            Self {
                progress: 0,
                total: 0,
                data: None,
            }
        }
    }
    impl RaptorQResultT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<RaptorQResult<'b>> {
            let progress = self.progress;
            let total = self.total;
            let data = self.data.as_ref().map(|x| _fbb.create_string(x));
            RaptorQResult::create(
                _fbb,
                &RaptorQResultArgs {
                    progress,
                    total,
                    data,
                },
            )
        }
    }
    pub enum AGEKeysOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AGEKeys<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AGEKeys<'a> {
        type Inner = AGEKeys<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AGEKeys<'a> {
        pub const VT_SK: flatbuffers::VOffsetT = 4;
        pub const VT_PK: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AGEKeys { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AGEKeysArgs<'args>,
        ) -> flatbuffers::WIPOffset<AGEKeys<'bldr>> {
            let mut builder = AGEKeysBuilder::new(_fbb);
            if let Some(x) = args.pk {
                builder.add_pk(x);
            }
            if let Some(x) = args.sk {
                builder.add_sk(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> AGEKeysT {
            let sk = self.sk().map(|x| x.to_string());
            let pk = self.pk().map(|x| x.to_string());
            AGEKeysT { sk, pk }
        }

        #[inline]
        pub fn sk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AGEKeys::VT_SK, None)
            }
        }
        #[inline]
        pub fn pk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AGEKeys::VT_PK, None)
            }
        }
    }

    impl flatbuffers::Verifiable for AGEKeys<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sk", Self::VT_SK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pk", Self::VT_PK, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AGEKeysArgs<'a> {
        pub sk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub pk: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for AGEKeysArgs<'a> {
        #[inline]
        fn default() -> Self {
            AGEKeysArgs { sk: None, pk: None }
        }
    }

    pub struct AGEKeysBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AGEKeysBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_sk(&mut self, sk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AGEKeys::VT_SK, sk);
        }
        #[inline]
        pub fn add_pk(&mut self, pk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AGEKeys::VT_PK, pk);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AGEKeysBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AGEKeysBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AGEKeys<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AGEKeys<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AGEKeys");
            ds.field("sk", &self.sk());
            ds.field("pk", &self.pk());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct AGEKeysT {
        pub sk: Option<String>,
        pub pk: Option<String>,
    }
    impl Default for AGEKeysT {
        fn default() -> Self {
            Self { sk: None, pk: None }
        }
    }
    impl AGEKeysT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<AGEKeys<'b>> {
            let sk = self.sk.as_ref().map(|x| _fbb.create_string(x));
            let pk = self.pk.as_ref().map(|x| _fbb.create_string(x));
            AGEKeys::create(_fbb, &AGEKeysArgs { sk, pk })
        }
    }
    pub enum ServersOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Servers<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Servers<'a> {
        type Inner = Servers<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Servers<'a> {
        pub const VT_URLS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Servers { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ServersArgs<'args>,
        ) -> flatbuffers::WIPOffset<Servers<'bldr>> {
            let mut builder = ServersBuilder::new(_fbb);
            if let Some(x) = args.urls {
                builder.add_urls(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> ServersT {
            let urls = self
                .urls()
                .map(|x| x.iter().map(|s| s.to_string()).collect());
            ServersT { urls }
        }

        #[inline]
        pub fn urls(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(Servers::VT_URLS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Servers<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("urls", Self::VT_URLS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ServersArgs<'a> {
        pub urls: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
    }
    impl<'a> Default for ServersArgs<'a> {
        #[inline]
        fn default() -> Self {
            ServersArgs { urls: None }
        }
    }

    pub struct ServersBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ServersBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_urls(
            &mut self,
            urls: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Servers::VT_URLS, urls);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ServersBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ServersBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Servers<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Servers<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Servers");
            ds.field("urls", &self.urls());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ServersT {
        pub urls: Option<Vec<String>>,
    }
    impl Default for ServersT {
        fn default() -> Self {
            Self { urls: None }
        }
    }
    impl ServersT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Servers<'b>> {
            let urls = self.urls.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
                _fbb.create_vector(&w)
            });
            Servers::create(_fbb, &ServersArgs { urls })
        }
    }
    pub enum ProgressOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Progress<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Progress<'a> {
        type Inner = Progress<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Progress<'a> {
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 6;
        pub const VT_TRIAL_DECRYPTIONS: flatbuffers::VOffsetT = 8;
        pub const VT_DOWNLOADED: flatbuffers::VOffsetT = 10;
        pub const VT_BALANCES: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Progress { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ProgressArgs<'args>,
        ) -> flatbuffers::WIPOffset<Progress<'bldr>> {
            let mut builder = ProgressBuilder::new(_fbb);
            builder.add_downloaded(args.downloaded);
            builder.add_trial_decryptions(args.trial_decryptions);
            if let Some(x) = args.balances {
                builder.add_balances(x);
            }
            builder.add_timestamp(args.timestamp);
            builder.add_height(args.height);
            builder.finish()
        }

        pub fn unpack(&self) -> ProgressT {
            let height = self.height();
            let timestamp = self.timestamp();
            let trial_decryptions = self.trial_decryptions();
            let downloaded = self.downloaded();
            let balances = self.balances().map(|x| Box::new(x.unpack()));
            ProgressT {
                height,
                timestamp,
                trial_decryptions,
                downloaded,
                balances,
            }
        }

        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Progress::VT_HEIGHT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Progress::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn trial_decryptions(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(Progress::VT_TRIAL_DECRYPTIONS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn downloaded(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(Progress::VT_DOWNLOADED, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn balances(&self) -> Option<PoolBalance<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<PoolBalance>>(Progress::VT_BALANCES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Progress<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<u64>("trial_decryptions", Self::VT_TRIAL_DECRYPTIONS, false)?
                .visit_field::<u64>("downloaded", Self::VT_DOWNLOADED, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<PoolBalance>>(
                    "balances",
                    Self::VT_BALANCES,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ProgressArgs<'a> {
        pub height: u32,
        pub timestamp: u32,
        pub trial_decryptions: u64,
        pub downloaded: u64,
        pub balances: Option<flatbuffers::WIPOffset<PoolBalance<'a>>>,
    }
    impl<'a> Default for ProgressArgs<'a> {
        #[inline]
        fn default() -> Self {
            ProgressArgs {
                height: 0,
                timestamp: 0,
                trial_decryptions: 0,
                downloaded: 0,
                balances: None,
            }
        }
    }

    pub struct ProgressBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProgressBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(Progress::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(Progress::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_trial_decryptions(&mut self, trial_decryptions: u64) {
            self.fbb_
                .push_slot::<u64>(Progress::VT_TRIAL_DECRYPTIONS, trial_decryptions, 0);
        }
        #[inline]
        pub fn add_downloaded(&mut self, downloaded: u64) {
            self.fbb_
                .push_slot::<u64>(Progress::VT_DOWNLOADED, downloaded, 0);
        }
        #[inline]
        pub fn add_balances(&mut self, balances: flatbuffers::WIPOffset<PoolBalance<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<PoolBalance>>(
                    Progress::VT_BALANCES,
                    balances,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> ProgressBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ProgressBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Progress<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Progress<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Progress");
            ds.field("height", &self.height());
            ds.field("timestamp", &self.timestamp());
            ds.field("trial_decryptions", &self.trial_decryptions());
            ds.field("downloaded", &self.downloaded());
            ds.field("balances", &self.balances());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ProgressT {
        pub height: u32,
        pub timestamp: u32,
        pub trial_decryptions: u64,
        pub downloaded: u64,
        pub balances: Option<Box<PoolBalanceT>>,
    }
    impl Default for ProgressT {
        fn default() -> Self {
            Self {
                height: 0,
                timestamp: 0,
                trial_decryptions: 0,
                downloaded: 0,
                balances: None,
            }
        }
    }
    impl ProgressT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Progress<'b>> {
            let height = self.height;
            let timestamp = self.timestamp;
            let trial_decryptions = self.trial_decryptions;
            let downloaded = self.downloaded;
            let balances = self.balances.as_ref().map(|x| x.pack(_fbb));
            Progress::create(
                _fbb,
                &ProgressArgs {
                    height,
                    timestamp,
                    trial_decryptions,
                    downloaded,
                    balances,
                },
            )
        }
    }
    pub enum KeyPackOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct KeyPack<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for KeyPack<'a> {
        type Inner = KeyPack<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> KeyPack<'a> {
        pub const VT_T_ADDR: flatbuffers::VOffsetT = 4;
        pub const VT_T_KEY: flatbuffers::VOffsetT = 6;
        pub const VT_Z_ADDR: flatbuffers::VOffsetT = 8;
        pub const VT_Z_KEY: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            KeyPack { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args KeyPackArgs<'args>,
        ) -> flatbuffers::WIPOffset<KeyPack<'bldr>> {
            let mut builder = KeyPackBuilder::new(_fbb);
            if let Some(x) = args.z_key {
                builder.add_z_key(x);
            }
            if let Some(x) = args.z_addr {
                builder.add_z_addr(x);
            }
            if let Some(x) = args.t_key {
                builder.add_t_key(x);
            }
            if let Some(x) = args.t_addr {
                builder.add_t_addr(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> KeyPackT {
            let t_addr = self.t_addr().map(|x| x.to_string());
            let t_key = self.t_key().map(|x| x.to_string());
            let z_addr = self.z_addr().map(|x| x.to_string());
            let z_key = self.z_key().map(|x| x.to_string());
            KeyPackT {
                t_addr,
                t_key,
                z_addr,
                z_key,
            }
        }

        #[inline]
        pub fn t_addr(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(KeyPack::VT_T_ADDR, None)
            }
        }
        #[inline]
        pub fn t_key(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(KeyPack::VT_T_KEY, None)
            }
        }
        #[inline]
        pub fn z_addr(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(KeyPack::VT_Z_ADDR, None)
            }
        }
        #[inline]
        pub fn z_key(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(KeyPack::VT_Z_KEY, None)
            }
        }
    }

    impl flatbuffers::Verifiable for KeyPack<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "t_addr",
                    Self::VT_T_ADDR,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("t_key", Self::VT_T_KEY, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "z_addr",
                    Self::VT_Z_ADDR,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("z_key", Self::VT_Z_KEY, false)?
                .finish();
            Ok(())
        }
    }
    pub struct KeyPackArgs<'a> {
        pub t_addr: Option<flatbuffers::WIPOffset<&'a str>>,
        pub t_key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub z_addr: Option<flatbuffers::WIPOffset<&'a str>>,
        pub z_key: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for KeyPackArgs<'a> {
        #[inline]
        fn default() -> Self {
            KeyPackArgs {
                t_addr: None,
                t_key: None,
                z_addr: None,
                z_key: None,
            }
        }
    }

    pub struct KeyPackBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KeyPackBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_t_addr(&mut self, t_addr: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(KeyPack::VT_T_ADDR, t_addr);
        }
        #[inline]
        pub fn add_t_key(&mut self, t_key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(KeyPack::VT_T_KEY, t_key);
        }
        #[inline]
        pub fn add_z_addr(&mut self, z_addr: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(KeyPack::VT_Z_ADDR, z_addr);
        }
        #[inline]
        pub fn add_z_key(&mut self, z_key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(KeyPack::VT_Z_KEY, z_key);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> KeyPackBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            KeyPackBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<KeyPack<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for KeyPack<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("KeyPack");
            ds.field("t_addr", &self.t_addr());
            ds.field("t_key", &self.t_key());
            ds.field("z_addr", &self.z_addr());
            ds.field("z_key", &self.z_key());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct KeyPackT {
        pub t_addr: Option<String>,
        pub t_key: Option<String>,
        pub z_addr: Option<String>,
        pub z_key: Option<String>,
    }
    impl Default for KeyPackT {
        fn default() -> Self {
            Self {
                t_addr: None,
                t_key: None,
                z_addr: None,
                z_key: None,
            }
        }
    }
    impl KeyPackT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<KeyPack<'b>> {
            let t_addr = self.t_addr.as_ref().map(|x| _fbb.create_string(x));
            let t_key = self.t_key.as_ref().map(|x| _fbb.create_string(x));
            let z_addr = self.z_addr.as_ref().map(|x| _fbb.create_string(x));
            let z_key = self.z_key.as_ref().map(|x| _fbb.create_string(x));
            KeyPack::create(
                _fbb,
                &KeyPackArgs {
                    t_addr,
                    t_key,
                    z_addr,
                    z_key,
                },
            )
        }
    }
    pub enum RecipientOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Recipient<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Recipient<'a> {
        type Inner = Recipient<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Recipient<'a> {
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
        pub const VT_POOLS: flatbuffers::VOffsetT = 6;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 8;
        pub const VT_FEE_INCLUDED: flatbuffers::VOffsetT = 10;
        pub const VT_REPLY_TO: flatbuffers::VOffsetT = 12;
        pub const VT_SUBJECT: flatbuffers::VOffsetT = 14;
        pub const VT_MEMO: flatbuffers::VOffsetT = 16;
        pub const VT_MAX_AMOUNT_PER_NOTE: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Recipient { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args RecipientArgs<'args>,
        ) -> flatbuffers::WIPOffset<Recipient<'bldr>> {
            let mut builder = RecipientBuilder::new(_fbb);
            builder.add_max_amount_per_note(args.max_amount_per_note);
            builder.add_amount(args.amount);
            if let Some(x) = args.memo {
                builder.add_memo(x);
            }
            if let Some(x) = args.subject {
                builder.add_subject(x);
            }
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.add_reply_to(args.reply_to);
            builder.add_fee_included(args.fee_included);
            builder.add_pools(args.pools);
            builder.finish()
        }

        pub fn unpack(&self) -> RecipientT {
            let address = self.address().map(|x| x.to_string());
            let pools = self.pools();
            let amount = self.amount();
            let fee_included = self.fee_included();
            let reply_to = self.reply_to();
            let subject = self.subject().map(|x| x.to_string());
            let memo = self.memo().map(|x| x.to_string());
            let max_amount_per_note = self.max_amount_per_note();
            RecipientT {
                address,
                pools,
                amount,
                fee_included,
                reply_to,
                subject,
                memo,
                max_amount_per_note,
            }
        }

        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Recipient::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn pools(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u8>(Recipient::VT_POOLS, Some(0)).unwrap() }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Recipient::VT_AMOUNT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn fee_included(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Recipient::VT_FEE_INCLUDED, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn reply_to(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Recipient::VT_REPLY_TO, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn subject(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Recipient::VT_SUBJECT, None)
            }
        }
        #[inline]
        pub fn memo(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Recipient::VT_MEMO, None)
            }
        }
        #[inline]
        pub fn max_amount_per_note(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(Recipient::VT_MAX_AMOUNT_PER_NOTE, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Recipient<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u8>("pools", Self::VT_POOLS, false)?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<bool>("fee_included", Self::VT_FEE_INCLUDED, false)?
                .visit_field::<bool>("reply_to", Self::VT_REPLY_TO, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "subject",
                    Self::VT_SUBJECT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memo", Self::VT_MEMO, false)?
                .visit_field::<u64>("max_amount_per_note", Self::VT_MAX_AMOUNT_PER_NOTE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RecipientArgs<'a> {
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub pools: u8,
        pub amount: u64,
        pub fee_included: bool,
        pub reply_to: bool,
        pub subject: Option<flatbuffers::WIPOffset<&'a str>>,
        pub memo: Option<flatbuffers::WIPOffset<&'a str>>,
        pub max_amount_per_note: u64,
    }
    impl<'a> Default for RecipientArgs<'a> {
        #[inline]
        fn default() -> Self {
            RecipientArgs {
                address: None,
                pools: 0,
                amount: 0,
                fee_included: false,
                reply_to: false,
                subject: None,
                memo: None,
                max_amount_per_note: 0,
            }
        }
    }

    pub struct RecipientBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RecipientBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Recipient::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_pools(&mut self, pools: u8) {
            self.fbb_.push_slot::<u8>(Recipient::VT_POOLS, pools, 0);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(Recipient::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_fee_included(&mut self, fee_included: bool) {
            self.fbb_
                .push_slot::<bool>(Recipient::VT_FEE_INCLUDED, fee_included, false);
        }
        #[inline]
        pub fn add_reply_to(&mut self, reply_to: bool) {
            self.fbb_
                .push_slot::<bool>(Recipient::VT_REPLY_TO, reply_to, false);
        }
        #[inline]
        pub fn add_subject(&mut self, subject: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Recipient::VT_SUBJECT, subject);
        }
        #[inline]
        pub fn add_memo(&mut self, memo: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Recipient::VT_MEMO, memo);
        }
        #[inline]
        pub fn add_max_amount_per_note(&mut self, max_amount_per_note: u64) {
            self.fbb_
                .push_slot::<u64>(Recipient::VT_MAX_AMOUNT_PER_NOTE, max_amount_per_note, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> RecipientBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            RecipientBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Recipient<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Recipient<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Recipient");
            ds.field("address", &self.address());
            ds.field("pools", &self.pools());
            ds.field("amount", &self.amount());
            ds.field("fee_included", &self.fee_included());
            ds.field("reply_to", &self.reply_to());
            ds.field("subject", &self.subject());
            ds.field("memo", &self.memo());
            ds.field("max_amount_per_note", &self.max_amount_per_note());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct RecipientT {
        pub address: Option<String>,
        pub pools: u8,
        pub amount: u64,
        pub fee_included: bool,
        pub reply_to: bool,
        pub subject: Option<String>,
        pub memo: Option<String>,
        pub max_amount_per_note: u64,
    }
    impl Default for RecipientT {
        fn default() -> Self {
            Self {
                address: None,
                pools: 0,
                amount: 0,
                fee_included: false,
                reply_to: false,
                subject: None,
                memo: None,
                max_amount_per_note: 0,
            }
        }
    }
    impl RecipientT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Recipient<'b>> {
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let pools = self.pools;
            let amount = self.amount;
            let fee_included = self.fee_included;
            let reply_to = self.reply_to;
            let subject = self.subject.as_ref().map(|x| _fbb.create_string(x));
            let memo = self.memo.as_ref().map(|x| _fbb.create_string(x));
            let max_amount_per_note = self.max_amount_per_note;
            Recipient::create(
                _fbb,
                &RecipientArgs {
                    address,
                    pools,
                    amount,
                    fee_included,
                    reply_to,
                    subject,
                    memo,
                    max_amount_per_note,
                },
            )
        }
    }
    pub enum RecipientsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Recipients<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Recipients<'a> {
        type Inner = Recipients<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Recipients<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Recipients { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args RecipientsArgs<'args>,
        ) -> flatbuffers::WIPOffset<Recipients<'bldr>> {
            let mut builder = RecipientsBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> RecipientsT {
            let values = self
                .values()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            RecipientsT { values }
        }

        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Recipient<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Recipient>>,
                >>(Recipients::VT_VALUES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Recipients<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Recipient>>,
                >>("values", Self::VT_VALUES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RecipientsArgs<'a> {
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Recipient<'a>>>,
            >,
        >,
    }
    impl<'a> Default for RecipientsArgs<'a> {
        #[inline]
        fn default() -> Self {
            RecipientsArgs { values: None }
        }
    }

    pub struct RecipientsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RecipientsBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Recipient<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Recipients::VT_VALUES, values);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> RecipientsBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            RecipientsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Recipients<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Recipients<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Recipients");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct RecipientsT {
        pub values: Option<Vec<RecipientT>>,
    }
    impl Default for RecipientsT {
        fn default() -> Self {
            Self { values: None }
        }
    }
    impl RecipientsT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Recipients<'b>> {
            let values = self.values.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            Recipients::create(_fbb, &RecipientsArgs { values })
        }
    }
    pub enum RecipientSummaryOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RecipientSummary<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RecipientSummary<'a> {
        type Inner = RecipientSummary<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> RecipientSummary<'a> {
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 4;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RecipientSummary { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args RecipientSummaryArgs<'args>,
        ) -> flatbuffers::WIPOffset<RecipientSummary<'bldr>> {
            let mut builder = RecipientSummaryBuilder::new(_fbb);
            builder.add_amount(args.amount);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> RecipientSummaryT {
            let amount = self.amount();
            let address = self.address().map(|x| x.to_string());
            RecipientSummaryT { amount, address }
        }

        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(RecipientSummary::VT_AMOUNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(RecipientSummary::VT_ADDRESS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for RecipientSummary<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct RecipientSummaryArgs<'a> {
        pub amount: u64,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for RecipientSummaryArgs<'a> {
        #[inline]
        fn default() -> Self {
            RecipientSummaryArgs {
                amount: 0,
                address: None,
            }
        }
    }

    pub struct RecipientSummaryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RecipientSummaryBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_
                .push_slot::<u64>(RecipientSummary::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                RecipientSummary::VT_ADDRESS,
                address,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> RecipientSummaryBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            RecipientSummaryBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RecipientSummary<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RecipientSummary<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RecipientSummary");
            ds.field("amount", &self.amount());
            ds.field("address", &self.address());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct RecipientSummaryT {
        pub amount: u64,
        pub address: Option<String>,
    }
    impl Default for RecipientSummaryT {
        fn default() -> Self {
            Self {
                amount: 0,
                address: None,
            }
        }
    }
    impl RecipientSummaryT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<RecipientSummary<'b>> {
            let amount = self.amount;
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            RecipientSummary::create(_fbb, &RecipientSummaryArgs { amount, address })
        }
    }
    pub enum UnsignedTxSummaryOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UnsignedTxSummary<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnsignedTxSummary<'a> {
        type Inner = UnsignedTxSummary<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UnsignedTxSummary<'a> {
        pub const VT_RECIPIENTS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnsignedTxSummary { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UnsignedTxSummaryArgs<'args>,
        ) -> flatbuffers::WIPOffset<UnsignedTxSummary<'bldr>> {
            let mut builder = UnsignedTxSummaryBuilder::new(_fbb);
            if let Some(x) = args.recipients {
                builder.add_recipients(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> UnsignedTxSummaryT {
            let recipients = self
                .recipients()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            UnsignedTxSummaryT { recipients }
        }

        #[inline]
        pub fn recipients(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RecipientSummary<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RecipientSummary>>,
                >>(UnsignedTxSummary::VT_RECIPIENTS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for UnsignedTxSummary<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RecipientSummary>>,
                >>("recipients", Self::VT_RECIPIENTS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UnsignedTxSummaryArgs<'a> {
        pub recipients: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RecipientSummary<'a>>>,
            >,
        >,
    }
    impl<'a> Default for UnsignedTxSummaryArgs<'a> {
        #[inline]
        fn default() -> Self {
            UnsignedTxSummaryArgs { recipients: None }
        }
    }

    pub struct UnsignedTxSummaryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnsignedTxSummaryBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_recipients(
            &mut self,
            recipients: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<RecipientSummary<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UnsignedTxSummary::VT_RECIPIENTS,
                recipients,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UnsignedTxSummaryBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UnsignedTxSummaryBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnsignedTxSummary<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UnsignedTxSummary<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UnsignedTxSummary");
            ds.field("recipients", &self.recipients());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct UnsignedTxSummaryT {
        pub recipients: Option<Vec<RecipientSummaryT>>,
    }
    impl Default for UnsignedTxSummaryT {
        fn default() -> Self {
            Self { recipients: None }
        }
    }
    impl UnsignedTxSummaryT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<UnsignedTxSummary<'b>> {
            let recipients = self.recipients.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            UnsignedTxSummary::create(_fbb, &UnsignedTxSummaryArgs { recipients })
        }
    }
    pub enum TxOutputOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TxOutput<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TxOutput<'a> {
        type Inner = TxOutput<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TxOutput<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 6;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 8;
        pub const VT_POOL: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TxOutput { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TxOutputArgs<'args>,
        ) -> flatbuffers::WIPOffset<TxOutput<'bldr>> {
            let mut builder = TxOutputBuilder::new(_fbb);
            builder.add_amount(args.amount);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.add_id(args.id);
            builder.add_pool(args.pool);
            builder.finish()
        }

        pub fn unpack(&self) -> TxOutputT {
            let id = self.id();
            let address = self.address().map(|x| x.to_string());
            let amount = self.amount();
            let pool = self.pool();
            TxOutputT {
                id,
                address,
                amount,
                pool,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(TxOutput::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TxOutput::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(TxOutput::VT_AMOUNT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn pool(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u8>(TxOutput::VT_POOL, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for TxOutput<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<u8>("pool", Self::VT_POOL, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TxOutputArgs<'a> {
        pub id: u32,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub amount: u64,
        pub pool: u8,
    }
    impl<'a> Default for TxOutputArgs<'a> {
        #[inline]
        fn default() -> Self {
            TxOutputArgs {
                id: 0,
                address: None,
                amount: 0,
                pool: 0,
            }
        }
    }

    pub struct TxOutputBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TxOutputBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(TxOutput::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TxOutput::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(TxOutput::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_pool(&mut self, pool: u8) {
            self.fbb_.push_slot::<u8>(TxOutput::VT_POOL, pool, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TxOutputBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TxOutputBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TxOutput<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TxOutput<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TxOutput");
            ds.field("id", &self.id());
            ds.field("address", &self.address());
            ds.field("amount", &self.amount());
            ds.field("pool", &self.pool());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TxOutputT {
        pub id: u32,
        pub address: Option<String>,
        pub amount: u64,
        pub pool: u8,
    }
    impl Default for TxOutputT {
        fn default() -> Self {
            Self {
                id: 0,
                address: None,
                amount: 0,
                pool: 0,
            }
        }
    }
    impl TxOutputT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TxOutput<'b>> {
            let id = self.id;
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let amount = self.amount;
            let pool = self.pool;
            TxOutput::create(
                _fbb,
                &TxOutputArgs {
                    id,
                    address,
                    amount,
                    pool,
                },
            )
        }
    }
    pub enum TxReportOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TxReport<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TxReport<'a> {
        type Inner = TxReport<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TxReport<'a> {
        pub const VT_OUTPUTS: flatbuffers::VOffsetT = 4;
        pub const VT_TRANSPARENT: flatbuffers::VOffsetT = 6;
        pub const VT_SAPLING: flatbuffers::VOffsetT = 8;
        pub const VT_ORCHARD: flatbuffers::VOffsetT = 10;
        pub const VT_NET_SAPLING: flatbuffers::VOffsetT = 12;
        pub const VT_NET_ORCHARD: flatbuffers::VOffsetT = 14;
        pub const VT_FEE: flatbuffers::VOffsetT = 16;
        pub const VT_PRIVACY_LEVEL: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TxReport { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TxReportArgs<'args>,
        ) -> flatbuffers::WIPOffset<TxReport<'bldr>> {
            let mut builder = TxReportBuilder::new(_fbb);
            builder.add_fee(args.fee);
            builder.add_net_orchard(args.net_orchard);
            builder.add_net_sapling(args.net_sapling);
            builder.add_orchard(args.orchard);
            builder.add_sapling(args.sapling);
            builder.add_transparent(args.transparent);
            if let Some(x) = args.outputs {
                builder.add_outputs(x);
            }
            builder.add_privacy_level(args.privacy_level);
            builder.finish()
        }

        pub fn unpack(&self) -> TxReportT {
            let outputs = self
                .outputs()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            let transparent = self.transparent();
            let sapling = self.sapling();
            let orchard = self.orchard();
            let net_sapling = self.net_sapling();
            let net_orchard = self.net_orchard();
            let fee = self.fee();
            let privacy_level = self.privacy_level();
            TxReportT {
                outputs,
                transparent,
                sapling,
                orchard,
                net_sapling,
                net_orchard,
                fee,
                privacy_level,
            }
        }

        #[inline]
        pub fn outputs(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TxOutput<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TxOutput>>,
                >>(TxReport::VT_OUTPUTS, None)
            }
        }
        #[inline]
        pub fn transparent(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(TxReport::VT_TRANSPARENT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn sapling(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(TxReport::VT_SAPLING, Some(0)).unwrap() }
        }
        #[inline]
        pub fn orchard(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(TxReport::VT_ORCHARD, Some(0)).unwrap() }
        }
        #[inline]
        pub fn net_sapling(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(TxReport::VT_NET_SAPLING, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn net_orchard(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(TxReport::VT_NET_ORCHARD, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fee(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(TxReport::VT_FEE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn privacy_level(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(TxReport::VT_PRIVACY_LEVEL, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for TxReport<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TxOutput>>,
                >>("outputs", Self::VT_OUTPUTS, false)?
                .visit_field::<u64>("transparent", Self::VT_TRANSPARENT, false)?
                .visit_field::<u64>("sapling", Self::VT_SAPLING, false)?
                .visit_field::<u64>("orchard", Self::VT_ORCHARD, false)?
                .visit_field::<i64>("net_sapling", Self::VT_NET_SAPLING, false)?
                .visit_field::<i64>("net_orchard", Self::VT_NET_ORCHARD, false)?
                .visit_field::<u64>("fee", Self::VT_FEE, false)?
                .visit_field::<u8>("privacy_level", Self::VT_PRIVACY_LEVEL, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TxReportArgs<'a> {
        pub outputs: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TxOutput<'a>>>,
            >,
        >,
        pub transparent: u64,
        pub sapling: u64,
        pub orchard: u64,
        pub net_sapling: i64,
        pub net_orchard: i64,
        pub fee: u64,
        pub privacy_level: u8,
    }
    impl<'a> Default for TxReportArgs<'a> {
        #[inline]
        fn default() -> Self {
            TxReportArgs {
                outputs: None,
                transparent: 0,
                sapling: 0,
                orchard: 0,
                net_sapling: 0,
                net_orchard: 0,
                fee: 0,
                privacy_level: 0,
            }
        }
    }

    pub struct TxReportBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TxReportBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_outputs(
            &mut self,
            outputs: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TxOutput<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TxReport::VT_OUTPUTS, outputs);
        }
        #[inline]
        pub fn add_transparent(&mut self, transparent: u64) {
            self.fbb_
                .push_slot::<u64>(TxReport::VT_TRANSPARENT, transparent, 0);
        }
        #[inline]
        pub fn add_sapling(&mut self, sapling: u64) {
            self.fbb_.push_slot::<u64>(TxReport::VT_SAPLING, sapling, 0);
        }
        #[inline]
        pub fn add_orchard(&mut self, orchard: u64) {
            self.fbb_.push_slot::<u64>(TxReport::VT_ORCHARD, orchard, 0);
        }
        #[inline]
        pub fn add_net_sapling(&mut self, net_sapling: i64) {
            self.fbb_
                .push_slot::<i64>(TxReport::VT_NET_SAPLING, net_sapling, 0);
        }
        #[inline]
        pub fn add_net_orchard(&mut self, net_orchard: i64) {
            self.fbb_
                .push_slot::<i64>(TxReport::VT_NET_ORCHARD, net_orchard, 0);
        }
        #[inline]
        pub fn add_fee(&mut self, fee: u64) {
            self.fbb_.push_slot::<u64>(TxReport::VT_FEE, fee, 0);
        }
        #[inline]
        pub fn add_privacy_level(&mut self, privacy_level: u8) {
            self.fbb_
                .push_slot::<u8>(TxReport::VT_PRIVACY_LEVEL, privacy_level, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TxReportBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TxReportBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TxReport<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TxReport<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TxReport");
            ds.field("outputs", &self.outputs());
            ds.field("transparent", &self.transparent());
            ds.field("sapling", &self.sapling());
            ds.field("orchard", &self.orchard());
            ds.field("net_sapling", &self.net_sapling());
            ds.field("net_orchard", &self.net_orchard());
            ds.field("fee", &self.fee());
            ds.field("privacy_level", &self.privacy_level());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TxReportT {
        pub outputs: Option<Vec<TxOutputT>>,
        pub transparent: u64,
        pub sapling: u64,
        pub orchard: u64,
        pub net_sapling: i64,
        pub net_orchard: i64,
        pub fee: u64,
        pub privacy_level: u8,
    }
    impl Default for TxReportT {
        fn default() -> Self {
            Self {
                outputs: None,
                transparent: 0,
                sapling: 0,
                orchard: 0,
                net_sapling: 0,
                net_orchard: 0,
                fee: 0,
                privacy_level: 0,
            }
        }
    }
    impl TxReportT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TxReport<'b>> {
            let outputs = self.outputs.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let transparent = self.transparent;
            let sapling = self.sapling;
            let orchard = self.orchard;
            let net_sapling = self.net_sapling;
            let net_orchard = self.net_orchard;
            let fee = self.fee;
            let privacy_level = self.privacy_level;
            TxReport::create(
                _fbb,
                &TxReportArgs {
                    outputs,
                    transparent,
                    sapling,
                    orchard,
                    net_sapling,
                    net_orchard,
                    fee,
                    privacy_level,
                },
            )
        }
    }
    pub enum FeeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Fee<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Fee<'a> {
        type Inner = Fee<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Fee<'a> {
        pub const VT_FEE: flatbuffers::VOffsetT = 4;
        pub const VT_MIN_FEE: flatbuffers::VOffsetT = 6;
        pub const VT_MAX_FEE: flatbuffers::VOffsetT = 8;
        pub const VT_SCHEME: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Fee { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args FeeArgs,
        ) -> flatbuffers::WIPOffset<Fee<'bldr>> {
            let mut builder = FeeBuilder::new(_fbb);
            builder.add_max_fee(args.max_fee);
            builder.add_min_fee(args.min_fee);
            builder.add_fee(args.fee);
            builder.add_scheme(args.scheme);
            builder.finish()
        }

        pub fn unpack(&self) -> FeeT {
            let fee = self.fee();
            let min_fee = self.min_fee();
            let max_fee = self.max_fee();
            let scheme = self.scheme();
            FeeT {
                fee,
                min_fee,
                max_fee,
                scheme,
            }
        }

        #[inline]
        pub fn fee(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Fee::VT_FEE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn min_fee(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Fee::VT_MIN_FEE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn max_fee(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Fee::VT_MAX_FEE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn scheme(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u8>(Fee::VT_SCHEME, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Fee<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("fee", Self::VT_FEE, false)?
                .visit_field::<u64>("min_fee", Self::VT_MIN_FEE, false)?
                .visit_field::<u64>("max_fee", Self::VT_MAX_FEE, false)?
                .visit_field::<u8>("scheme", Self::VT_SCHEME, false)?
                .finish();
            Ok(())
        }
    }
    pub struct FeeArgs {
        pub fee: u64,
        pub min_fee: u64,
        pub max_fee: u64,
        pub scheme: u8,
    }
    impl<'a> Default for FeeArgs {
        #[inline]
        fn default() -> Self {
            FeeArgs {
                fee: 0,
                min_fee: 0,
                max_fee: 0,
                scheme: 0,
            }
        }
    }

    pub struct FeeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FeeBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_fee(&mut self, fee: u64) {
            self.fbb_.push_slot::<u64>(Fee::VT_FEE, fee, 0);
        }
        #[inline]
        pub fn add_min_fee(&mut self, min_fee: u64) {
            self.fbb_.push_slot::<u64>(Fee::VT_MIN_FEE, min_fee, 0);
        }
        #[inline]
        pub fn add_max_fee(&mut self, max_fee: u64) {
            self.fbb_.push_slot::<u64>(Fee::VT_MAX_FEE, max_fee, 0);
        }
        #[inline]
        pub fn add_scheme(&mut self, scheme: u8) {
            self.fbb_.push_slot::<u8>(Fee::VT_SCHEME, scheme, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FeeBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            FeeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Fee<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Fee<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Fee");
            ds.field("fee", &self.fee());
            ds.field("min_fee", &self.min_fee());
            ds.field("max_fee", &self.max_fee());
            ds.field("scheme", &self.scheme());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct FeeT {
        pub fee: u64,
        pub min_fee: u64,
        pub max_fee: u64,
        pub scheme: u8,
    }
    impl Default for FeeT {
        fn default() -> Self {
            Self {
                fee: 0,
                min_fee: 0,
                max_fee: 0,
                scheme: 0,
            }
        }
    }
    impl FeeT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Fee<'b>> {
            let fee = self.fee;
            let min_fee = self.min_fee;
            let max_fee = self.max_fee;
            let scheme = self.scheme;
            Fee::create(
                _fbb,
                &FeeArgs {
                    fee,
                    min_fee,
                    max_fee,
                    scheme,
                },
            )
        }
    }
    pub enum PaymentURIOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PaymentURI<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PaymentURI<'a> {
        type Inner = PaymentURI<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PaymentURI<'a> {
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;
        pub const VT_MEMO: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PaymentURI { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args PaymentURIArgs<'args>,
        ) -> flatbuffers::WIPOffset<PaymentURI<'bldr>> {
            let mut builder = PaymentURIBuilder::new(_fbb);
            builder.add_amount(args.amount);
            if let Some(x) = args.memo {
                builder.add_memo(x);
            }
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> PaymentURIT {
            let address = self.address().map(|x| x.to_string());
            let amount = self.amount();
            let memo = self.memo().map(|x| x.to_string());
            PaymentURIT {
                address,
                amount,
                memo,
            }
        }

        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PaymentURI::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(PaymentURI::VT_AMOUNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn memo(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PaymentURI::VT_MEMO, None)
            }
        }
    }

    impl flatbuffers::Verifiable for PaymentURI<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memo", Self::VT_MEMO, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PaymentURIArgs<'a> {
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub amount: u64,
        pub memo: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for PaymentURIArgs<'a> {
        #[inline]
        fn default() -> Self {
            PaymentURIArgs {
                address: None,
                amount: 0,
                memo: None,
            }
        }
    }

    pub struct PaymentURIBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PaymentURIBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PaymentURI::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(PaymentURI::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_memo(&mut self, memo: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PaymentURI::VT_MEMO, memo);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> PaymentURIBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            PaymentURIBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PaymentURI<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PaymentURI<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PaymentURI");
            ds.field("address", &self.address());
            ds.field("amount", &self.amount());
            ds.field("memo", &self.memo());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct PaymentURIT {
        pub address: Option<String>,
        pub amount: u64,
        pub memo: Option<String>,
    }
    impl Default for PaymentURIT {
        fn default() -> Self {
            Self {
                address: None,
                amount: 0,
                memo: None,
            }
        }
    }
    impl PaymentURIT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<PaymentURI<'b>> {
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let amount = self.amount;
            let memo = self.memo.as_ref().map(|x| _fbb.create_string(x));
            PaymentURI::create(
                _fbb,
                &PaymentURIArgs {
                    address,
                    amount,
                    memo,
                },
            )
        }
    }
    pub enum AccountAddressOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AccountAddress<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AccountAddress<'a> {
        type Inner = AccountAddress<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AccountAddress<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;
        pub const VT_TRANSPARENT: flatbuffers::VOffsetT = 8;
        pub const VT_SAPLING: flatbuffers::VOffsetT = 10;
        pub const VT_ORCHARD: flatbuffers::VOffsetT = 12;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AccountAddress { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AccountAddressArgs<'args>,
        ) -> flatbuffers::WIPOffset<AccountAddress<'bldr>> {
            let mut builder = AccountAddressBuilder::new(_fbb);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            if let Some(x) = args.orchard {
                builder.add_orchard(x);
            }
            if let Some(x) = args.sapling {
                builder.add_sapling(x);
            }
            if let Some(x) = args.transparent {
                builder.add_transparent(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_id(args.id);
            builder.finish()
        }

        pub fn unpack(&self) -> AccountAddressT {
            let id = self.id();
            let name = self.name().map(|x| x.to_string());
            let transparent = self.transparent().map(|x| x.to_string());
            let sapling = self.sapling().map(|x| x.to_string());
            let orchard = self.orchard().map(|x| x.to_string());
            let address = self.address().map(|x| x.to_string());
            AccountAddressT {
                id,
                name,
                transparent,
                sapling,
                orchard,
                address,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(AccountAddress::VT_ID, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AccountAddress::VT_NAME, None)
            }
        }
        #[inline]
        pub fn transparent(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AccountAddress::VT_TRANSPARENT, None)
            }
        }
        #[inline]
        pub fn sapling(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AccountAddress::VT_SAPLING, None)
            }
        }
        #[inline]
        pub fn orchard(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AccountAddress::VT_ORCHARD, None)
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AccountAddress::VT_ADDRESS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for AccountAddress<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "transparent",
                    Self::VT_TRANSPARENT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "sapling",
                    Self::VT_SAPLING,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "orchard",
                    Self::VT_ORCHARD,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct AccountAddressArgs<'a> {
        pub id: u32,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub transparent: Option<flatbuffers::WIPOffset<&'a str>>,
        pub sapling: Option<flatbuffers::WIPOffset<&'a str>>,
        pub orchard: Option<flatbuffers::WIPOffset<&'a str>>,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for AccountAddressArgs<'a> {
        #[inline]
        fn default() -> Self {
            AccountAddressArgs {
                id: 0,
                name: None,
                transparent: None,
                sapling: None,
                orchard: None,
                address: None,
            }
        }
    }

    pub struct AccountAddressBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AccountAddressBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(AccountAddress::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AccountAddress::VT_NAME, name);
        }
        #[inline]
        pub fn add_transparent(&mut self, transparent: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                AccountAddress::VT_TRANSPARENT,
                transparent,
            );
        }
        #[inline]
        pub fn add_sapling(&mut self, sapling: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AccountAddress::VT_SAPLING, sapling);
        }
        #[inline]
        pub fn add_orchard(&mut self, orchard: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AccountAddress::VT_ORCHARD, orchard);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AccountAddress::VT_ADDRESS, address);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AccountAddressBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AccountAddressBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AccountAddress<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AccountAddress<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AccountAddress");
            ds.field("id", &self.id());
            ds.field("name", &self.name());
            ds.field("transparent", &self.transparent());
            ds.field("sapling", &self.sapling());
            ds.field("orchard", &self.orchard());
            ds.field("address", &self.address());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct AccountAddressT {
        pub id: u32,
        pub name: Option<String>,
        pub transparent: Option<String>,
        pub sapling: Option<String>,
        pub orchard: Option<String>,
        pub address: Option<String>,
    }
    impl Default for AccountAddressT {
        fn default() -> Self {
            Self {
                id: 0,
                name: None,
                transparent: None,
                sapling: None,
                orchard: None,
                address: None,
            }
        }
    }
    impl AccountAddressT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<AccountAddress<'b>> {
            let id = self.id;
            let name = self.name.as_ref().map(|x| _fbb.create_string(x));
            let transparent = self.transparent.as_ref().map(|x| _fbb.create_string(x));
            let sapling = self.sapling.as_ref().map(|x| _fbb.create_string(x));
            let orchard = self.orchard.as_ref().map(|x| _fbb.create_string(x));
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            AccountAddress::create(
                _fbb,
                &AccountAddressArgs {
                    id,
                    name,
                    transparent,
                    sapling,
                    orchard,
                    address,
                },
            )
        }
    }
    pub enum SwapOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Swap<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Swap<'a> {
        type Inner = Swap<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Swap<'a> {
        pub const VT_PROVIDER: flatbuffers::VOffsetT = 4;
        pub const VT_PROVIDER_ID: flatbuffers::VOffsetT = 6;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 8;
        pub const VT_FROM_CURRENCY: flatbuffers::VOffsetT = 10;
        pub const VT_FROM_AMOUNT: flatbuffers::VOffsetT = 12;
        pub const VT_FROM_ADDRESS: flatbuffers::VOffsetT = 14;
        pub const VT_FROM_IMAGE: flatbuffers::VOffsetT = 16;
        pub const VT_TO_CURRENCY: flatbuffers::VOffsetT = 18;
        pub const VT_TO_AMOUNT: flatbuffers::VOffsetT = 20;
        pub const VT_TO_ADDRESS: flatbuffers::VOffsetT = 22;
        pub const VT_TO_IMAGE: flatbuffers::VOffsetT = 24;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Swap { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SwapArgs<'args>,
        ) -> flatbuffers::WIPOffset<Swap<'bldr>> {
            let mut builder = SwapBuilder::new(_fbb);
            if let Some(x) = args.to_image {
                builder.add_to_image(x);
            }
            if let Some(x) = args.to_address {
                builder.add_to_address(x);
            }
            if let Some(x) = args.to_amount {
                builder.add_to_amount(x);
            }
            if let Some(x) = args.to_currency {
                builder.add_to_currency(x);
            }
            if let Some(x) = args.from_image {
                builder.add_from_image(x);
            }
            if let Some(x) = args.from_address {
                builder.add_from_address(x);
            }
            if let Some(x) = args.from_amount {
                builder.add_from_amount(x);
            }
            if let Some(x) = args.from_currency {
                builder.add_from_currency(x);
            }
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.provider_id {
                builder.add_provider_id(x);
            }
            if let Some(x) = args.provider {
                builder.add_provider(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> SwapT {
            let provider = self.provider().map(|x| x.to_string());
            let provider_id = self.provider_id().map(|x| x.to_string());
            let timestamp = self.timestamp();
            let from_currency = self.from_currency().map(|x| x.to_string());
            let from_amount = self.from_amount().map(|x| x.to_string());
            let from_address = self.from_address().map(|x| x.to_string());
            let from_image = self.from_image().map(|x| x.to_string());
            let to_currency = self.to_currency().map(|x| x.to_string());
            let to_amount = self.to_amount().map(|x| x.to_string());
            let to_address = self.to_address().map(|x| x.to_string());
            let to_image = self.to_image().map(|x| x.to_string());
            SwapT {
                provider,
                provider_id,
                timestamp,
                from_currency,
                from_amount,
                from_address,
                from_image,
                to_currency,
                to_amount,
                to_address,
                to_image,
            }
        }

        #[inline]
        pub fn provider(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Swap::VT_PROVIDER, None)
            }
        }
        #[inline]
        pub fn provider_id(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Swap::VT_PROVIDER_ID, None)
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Swap::VT_TIMESTAMP, Some(0)).unwrap() }
        }
        #[inline]
        pub fn from_currency(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Swap::VT_FROM_CURRENCY, None)
            }
        }
        #[inline]
        pub fn from_amount(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Swap::VT_FROM_AMOUNT, None)
            }
        }
        #[inline]
        pub fn from_address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Swap::VT_FROM_ADDRESS, None)
            }
        }
        #[inline]
        pub fn from_image(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Swap::VT_FROM_IMAGE, None)
            }
        }
        #[inline]
        pub fn to_currency(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Swap::VT_TO_CURRENCY, None)
            }
        }
        #[inline]
        pub fn to_amount(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Swap::VT_TO_AMOUNT, None)
            }
        }
        #[inline]
        pub fn to_address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Swap::VT_TO_ADDRESS, None)
            }
        }
        #[inline]
        pub fn to_image(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Swap::VT_TO_IMAGE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Swap<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "provider",
                    Self::VT_PROVIDER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "provider_id",
                    Self::VT_PROVIDER_ID,
                    false,
                )?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "from_currency",
                    Self::VT_FROM_CURRENCY,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "from_amount",
                    Self::VT_FROM_AMOUNT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "from_address",
                    Self::VT_FROM_ADDRESS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "from_image",
                    Self::VT_FROM_IMAGE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "to_currency",
                    Self::VT_TO_CURRENCY,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "to_amount",
                    Self::VT_TO_AMOUNT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "to_address",
                    Self::VT_TO_ADDRESS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "to_image",
                    Self::VT_TO_IMAGE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SwapArgs<'a> {
        pub provider: Option<flatbuffers::WIPOffset<&'a str>>,
        pub provider_id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub timestamp: u32,
        pub from_currency: Option<flatbuffers::WIPOffset<&'a str>>,
        pub from_amount: Option<flatbuffers::WIPOffset<&'a str>>,
        pub from_address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub from_image: Option<flatbuffers::WIPOffset<&'a str>>,
        pub to_currency: Option<flatbuffers::WIPOffset<&'a str>>,
        pub to_amount: Option<flatbuffers::WIPOffset<&'a str>>,
        pub to_address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub to_image: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for SwapArgs<'a> {
        #[inline]
        fn default() -> Self {
            SwapArgs {
                provider: None,
                provider_id: None,
                timestamp: 0,
                from_currency: None,
                from_amount: None,
                from_address: None,
                from_image: None,
                to_currency: None,
                to_amount: None,
                to_address: None,
                to_image: None,
            }
        }
    }

    pub struct SwapBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SwapBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_provider(&mut self, provider: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Swap::VT_PROVIDER, provider);
        }
        #[inline]
        pub fn add_provider_id(&mut self, provider_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Swap::VT_PROVIDER_ID, provider_id);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_.push_slot::<u32>(Swap::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_from_currency(&mut self, from_currency: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Swap::VT_FROM_CURRENCY,
                from_currency,
            );
        }
        #[inline]
        pub fn add_from_amount(&mut self, from_amount: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Swap::VT_FROM_AMOUNT, from_amount);
        }
        #[inline]
        pub fn add_from_address(&mut self, from_address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Swap::VT_FROM_ADDRESS, from_address);
        }
        #[inline]
        pub fn add_from_image(&mut self, from_image: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Swap::VT_FROM_IMAGE, from_image);
        }
        #[inline]
        pub fn add_to_currency(&mut self, to_currency: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Swap::VT_TO_CURRENCY, to_currency);
        }
        #[inline]
        pub fn add_to_amount(&mut self, to_amount: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Swap::VT_TO_AMOUNT, to_amount);
        }
        #[inline]
        pub fn add_to_address(&mut self, to_address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Swap::VT_TO_ADDRESS, to_address);
        }
        #[inline]
        pub fn add_to_image(&mut self, to_image: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Swap::VT_TO_IMAGE, to_image);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SwapBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SwapBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Swap<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Swap<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Swap");
            ds.field("provider", &self.provider());
            ds.field("provider_id", &self.provider_id());
            ds.field("timestamp", &self.timestamp());
            ds.field("from_currency", &self.from_currency());
            ds.field("from_amount", &self.from_amount());
            ds.field("from_address", &self.from_address());
            ds.field("from_image", &self.from_image());
            ds.field("to_currency", &self.to_currency());
            ds.field("to_amount", &self.to_amount());
            ds.field("to_address", &self.to_address());
            ds.field("to_image", &self.to_image());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct SwapT {
        pub provider: Option<String>,
        pub provider_id: Option<String>,
        pub timestamp: u32,
        pub from_currency: Option<String>,
        pub from_amount: Option<String>,
        pub from_address: Option<String>,
        pub from_image: Option<String>,
        pub to_currency: Option<String>,
        pub to_amount: Option<String>,
        pub to_address: Option<String>,
        pub to_image: Option<String>,
    }
    impl Default for SwapT {
        fn default() -> Self {
            Self {
                provider: None,
                provider_id: None,
                timestamp: 0,
                from_currency: None,
                from_amount: None,
                from_address: None,
                from_image: None,
                to_currency: None,
                to_amount: None,
                to_address: None,
                to_image: None,
            }
        }
    }
    impl SwapT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Swap<'b>> {
            let provider = self.provider.as_ref().map(|x| _fbb.create_string(x));
            let provider_id = self.provider_id.as_ref().map(|x| _fbb.create_string(x));
            let timestamp = self.timestamp;
            let from_currency = self.from_currency.as_ref().map(|x| _fbb.create_string(x));
            let from_amount = self.from_amount.as_ref().map(|x| _fbb.create_string(x));
            let from_address = self.from_address.as_ref().map(|x| _fbb.create_string(x));
            let from_image = self.from_image.as_ref().map(|x| _fbb.create_string(x));
            let to_currency = self.to_currency.as_ref().map(|x| _fbb.create_string(x));
            let to_amount = self.to_amount.as_ref().map(|x| _fbb.create_string(x));
            let to_address = self.to_address.as_ref().map(|x| _fbb.create_string(x));
            let to_image = self.to_image.as_ref().map(|x| _fbb.create_string(x));
            Swap::create(
                _fbb,
                &SwapArgs {
                    provider,
                    provider_id,
                    timestamp,
                    from_currency,
                    from_amount,
                    from_address,
                    from_image,
                    to_currency,
                    to_amount,
                    to_address,
                    to_image,
                },
            )
        }
    }
    pub enum SwapVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SwapVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SwapVec<'a> {
        type Inner = SwapVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SwapVec<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SwapVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SwapVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<SwapVec<'bldr>> {
            let mut builder = SwapVecBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> SwapVecT {
            let values = self
                .values()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            SwapVecT { values }
        }

        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Swap<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Swap>>,
                >>(SwapVec::VT_VALUES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for SwapVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Swap>>,
                >>("values", Self::VT_VALUES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SwapVecArgs<'a> {
        pub values: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Swap<'a>>>>,
        >,
    }
    impl<'a> Default for SwapVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            SwapVecArgs { values: None }
        }
    }

    pub struct SwapVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SwapVecBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Swap<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SwapVec::VT_VALUES, values);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SwapVecBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SwapVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SwapVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SwapVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SwapVec");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct SwapVecT {
        pub values: Option<Vec<SwapT>>,
    }
    impl Default for SwapVecT {
        fn default() -> Self {
            Self { values: None }
        }
    }
    impl SwapVecT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<SwapVec<'b>> {
            let values = self.values.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            SwapVec::create(_fbb, &SwapVecArgs { values })
        }
    }
    pub enum VoteNoteOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct VoteNote<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for VoteNote<'a> {
        type Inner = VoteNote<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> VoteNote<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;
        pub const VT_SELECTED: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            VoteNote { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args VoteNoteArgs,
        ) -> flatbuffers::WIPOffset<VoteNote<'bldr>> {
            let mut builder = VoteNoteBuilder::new(_fbb);
            builder.add_value(args.value);
            builder.add_height(args.height);
            builder.add_id(args.id);
            builder.add_selected(args.selected);
            builder.finish()
        }

        pub fn unpack(&self) -> VoteNoteT {
            let id = self.id();
            let height = self.height();
            let value = self.value();
            let selected = self.selected();
            VoteNoteT {
                id,
                height,
                value,
                selected,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(VoteNote::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(VoteNote::VT_HEIGHT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(VoteNote::VT_VALUE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn selected(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(VoteNote::VT_SELECTED, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for VoteNote<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u64>("value", Self::VT_VALUE, false)?
                .visit_field::<bool>("selected", Self::VT_SELECTED, false)?
                .finish();
            Ok(())
        }
    }
    pub struct VoteNoteArgs {
        pub id: u32,
        pub height: u32,
        pub value: u64,
        pub selected: bool,
    }
    impl<'a> Default for VoteNoteArgs {
        #[inline]
        fn default() -> Self {
            VoteNoteArgs {
                id: 0,
                height: 0,
                value: 0,
                selected: false,
            }
        }
    }

    pub struct VoteNoteBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VoteNoteBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(VoteNote::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(VoteNote::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_.push_slot::<u64>(VoteNote::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn add_selected(&mut self, selected: bool) {
            self.fbb_
                .push_slot::<bool>(VoteNote::VT_SELECTED, selected, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> VoteNoteBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            VoteNoteBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<VoteNote<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for VoteNote<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("VoteNote");
            ds.field("id", &self.id());
            ds.field("height", &self.height());
            ds.field("value", &self.value());
            ds.field("selected", &self.selected());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct VoteNoteT {
        pub id: u32,
        pub height: u32,
        pub value: u64,
        pub selected: bool,
    }
    impl Default for VoteNoteT {
        fn default() -> Self {
            Self {
                id: 0,
                height: 0,
                value: 0,
                selected: false,
            }
        }
    }
    impl VoteNoteT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<VoteNote<'b>> {
            let id = self.id;
            let height = self.height;
            let value = self.value;
            let selected = self.selected;
            VoteNote::create(
                _fbb,
                &VoteNoteArgs {
                    id,
                    height,
                    value,
                    selected,
                },
            )
        }
    }
    pub enum VoteNoteVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct VoteNoteVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for VoteNoteVec<'a> {
        type Inner = VoteNoteVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> VoteNoteVec<'a> {
        pub const VT_NOTES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            VoteNoteVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args VoteNoteVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<VoteNoteVec<'bldr>> {
            let mut builder = VoteNoteVecBuilder::new(_fbb);
            if let Some(x) = args.notes {
                builder.add_notes(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> VoteNoteVecT {
            let notes = self.notes().map(|x| x.iter().map(|t| t.unpack()).collect());
            VoteNoteVecT { notes }
        }

        #[inline]
        pub fn notes(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VoteNote<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VoteNote>>,
                >>(VoteNoteVec::VT_NOTES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for VoteNoteVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<VoteNote>>,
                >>("notes", Self::VT_NOTES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct VoteNoteVecArgs<'a> {
        pub notes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VoteNote<'a>>>,
            >,
        >,
    }
    impl<'a> Default for VoteNoteVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            VoteNoteVecArgs { notes: None }
        }
    }

    pub struct VoteNoteVecBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VoteNoteVecBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_notes(
            &mut self,
            notes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<VoteNote<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(VoteNoteVec::VT_NOTES, notes);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> VoteNoteVecBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            VoteNoteVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<VoteNoteVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for VoteNoteVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("VoteNoteVec");
            ds.field("notes", &self.notes());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct VoteNoteVecT {
        pub notes: Option<Vec<VoteNoteT>>,
    }
    impl Default for VoteNoteVecT {
        fn default() -> Self {
            Self { notes: None }
        }
    }
    impl VoteNoteVecT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<VoteNoteVec<'b>> {
            let notes = self.notes.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            VoteNoteVec::create(_fbb, &VoteNoteVecArgs { notes })
        }
    }
} // pub mod fb
